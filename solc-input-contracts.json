{
  "language": "Solidity",
  "sources": {
    "./contracts/erc4626/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity ^0.8.0;\r\n\r\n/// @title IERC4626\r\n/// https://eips.ethereum.org/EIPS/eip-4626\r\n///\r\n/// EIP-4626: Tokenized Vault Standard\r\n/// A standard for tokenized Vaults with a single underlying ERC-20 token.\r\n///\r\n/// Abstract\r\n/// The following standard allows for the implementation of a standard API for\r\n/// tokenized Vaults representing shares of a single underlying ERC-20 token.\r\n/// This standard is an extension on the ERC-20 token that provides basic\r\n/// functionality for depositing and withdrawing tokens and reading balances.\r\n///\r\n/// Motivation\r\n/// Tokenized Vaults have a lack of standardization leading to diverse\r\n/// implementation details. Some various examples include lending markets,\r\n/// aggregators, and intrinsically interest bearing tokens. This makes\r\n/// integration difficult at the aggregator or plugin layer for protocols which\r\n/// need to conform to many standards, and forces each protocol to implement\r\n/// their own adapters which are error prone and waste development resources.\r\n///\r\n/// A standard for tokenized Vaults will lower the integration effort for\r\n/// yield-bearing vaults, while creating more consistent and robust\r\n/// implementation patterns.\r\n///\r\n/// Specification\r\n/// All ERC-4626 tokenized Vaults MUST implement ERC-20 to represent shares.\r\n/// If a Vault is to be non-transferrable, it MAY revert on calls to transfer\r\n/// or transferFrom. The ERC-20 operations balanceOf, transfer, totalSupply,\r\n/// etc. operate on the Vault “shares” which represent a claim to ownership on\r\n/// a fraction of the Vault’s underlying holdings.\r\n///\r\n/// All ERC-4626 tokenized Vaults MUST implement ERC-20’s optional metadata\r\n/// extensions. The name and symbol functions SHOULD reflect the underlying\r\n/// token’s name and symbol in some way.\r\n///\r\n/// ERC-4626 tokenized Vaults MAY implement EIP-2612 to improve the UX of\r\n/// approving shares on various integrations.\r\n///\r\n///  Definitions:\r\n///  - asset: The underlying token managed by the Vault. Has units defined by\r\n///    the corresponding ERC-20 contract.\r\n///  - share: The token of the Vault. Has a ratio of underlying assets\r\n///    exchanged on mint/deposit/withdraw/redeem (as defined by the Vault).\r\n///  - fee: An amount of assets or shares charged to the user by the Vault.\r\n///    Fees can exists for deposits, yield, AUM, withdrawals, or anything else\r\n///    prescribed by the Vault.\r\n///  - slippage: Any difference between advertised share price and economic\r\n///    realities of deposit to or withdrawal from the Vault, which is not\r\n///    accounted by fees.\r\n///\r\n/// Rationale\r\n/// The Vault interface is designed to be optimized for integrators with a\r\n/// feature complete yet minimal interface. Details such as accounting and\r\n/// allocation of deposited tokens are intentionally not specified, as Vaults\r\n/// are expected to be treated as black boxes on-chain and inspected off-chain\r\n/// before use.\r\n///\r\n/// ERC-20 is enforced because implementation details like token approval and\r\n/// balance calculation directly carry over to the shares accounting. This\r\n/// standardization makes the Vaults immediately compatible with all ERC-20 use\r\n/// cases in addition to ERC-4626.\r\n///\r\n/// The mint method was included for symmetry and feature completeness. Most\r\n/// current use cases of share-based Vaults do not ascribe special meaning to\r\n/// the shares such that a user would optimize for a specific number of shares\r\n/// (mint) rather than specific amount of underlying (deposit). However, it is\r\n/// easy to imagine future Vault strategies which would have unique and\r\n/// independently useful share representations.\r\n///\r\n/// The convertTo functions serve as rough estimates that do not account for\r\n/// operation specific details like withdrawal fees, etc. They were included\r\n/// for frontends and applications that need an average value of shares or\r\n/// assets, not an exact value possibly including slippage or other fees. For\r\n/// applications that need an exact value that attempts to account for fees and\r\n/// slippage we have included a corresponding preview function to match each\r\n/// mutable function. These functions must not account for deposit or\r\n/// withdrawal limits, to ensure they are easily composable, the max functions\r\n/// are provided for that purpose.\r\n///\r\n/// Backwards Compatibility\r\n/// ERC-4626 is fully backward compatible with the ERC-20 standard and has no\r\n/// known compatibility issues with other standards. For production\r\n/// implementations of Vaults which do not use ERC-4626, wrapper adapters can\r\n/// be developed and used.\r\n///\r\n/// Security Considerations\r\n/// Fully permissionless use cases could fall prey to malicious implementations\r\n/// which only conform to the interface but not the specification. It is\r\n/// recommended that all integrators review the implementation for potential\r\n/// ways of losing user deposits before integrating.\r\n///\r\n/// If implementors intend to support EOA account access directly, they should\r\n/// consider adding an additional function call for\r\n/// deposit/mint/withdraw/redeem with the means to accommodate slippage loss or\r\n/// unexpected deposit/withdrawal limits, since they have no other means to\r\n/// revert the transaction if the exact output amount is not achieved.\r\n///\r\n/// The methods totalAssets, convertToShares and convertToAssets are estimates\r\n/// useful for display purposes, and do not have to confer the exact amount of\r\n/// underlying assets their context suggests.\r\n///\r\n/// The preview methods return values that are as close as possible to exact as\r\n/// possible. For that reason, they are manipulable by altering the on-chain\r\n/// conditions and are not always safe to be used as price oracles. This\r\n/// specification includes convert methods that are allowed to be inexact and\r\n/// therefore can be implemented as robust price oracles. For example, it would\r\n/// be correct to implement the convert methods as using a time-weighted\r\n/// average price in converting between assets and shares.\r\n///\r\n/// Integrators of ERC-4626 Vaults should be aware of the difference between\r\n/// these view methods when integrating with this standard. Additionally, note\r\n/// that the amount of underlying assets a user may receive from redeeming\r\n/// their Vault shares (previewRedeem) can be significantly different than the\r\n/// amount that would be taken from them when minting the same quantity of\r\n/// shares (previewMint). The differences may be small (like if due to rounding\r\n/// error), or very significant (like if a Vault implements withdrawal or\r\n/// deposit fees, etc). Therefore integrators should always take care to use\r\n/// the preview function most relevant to their use case, and never assume they\r\n/// are interchangeable.\r\n///\r\n/// Finally, ERC-4626 Vault implementers should be aware of the need for\r\n/// specific, opposing rounding directions across the different mutable and\r\n/// view methods, as it is considered most secure to favor the Vault itself\r\n/// during calculations over its users:\r\n///\r\n/// - If (1) it’s calculating how many shares to issue to a user for a certain\r\n///   amount of the underlying tokens they provide or (2) it’s determining the\r\n///   amount of the underlying tokens to transfer to them for returning a\r\n///   certain amount of shares, it should round down.\r\n/// - If (1) it’s calculating the amount of shares a user has to supply to\r\n///   receive a given amount of the underlying tokens or (2) it’s calculating\r\n///   the amount of underlying tokens a user has to provide to receive a\r\n///   certain amount of shares, it should round up.\r\n///\r\n/// The only functions where the preferred rounding direction would be\r\n/// ambiguous are the convertTo functions. To ensure consistency across all\r\n/// ERC-4626 Vault implementations it is specified that these functions MUST\r\n/// both always round down. Integrators may wish to mimic rounding up versions\r\n/// of these functions themselves, like by adding 1 wei to the result.\r\n///\r\n/// Although the convertTo functions should eliminate the need for any use of\r\n/// an ERC-4626 Vault’s decimals variable, it is still strongly recommended to\r\n/// mirror the underlying token’s decimals if at all possible, to eliminate\r\n/// possible sources of confusion and simplify integration across front-ends\r\n/// and for other off-chain users.\r\n///\r\n/// Copyright\r\n/// Copyright and related rights waived via CC0.\r\n///\r\n/// Citation\r\n/// Please cite this document as:\r\n/// Joey Santoro, t11s, Jet Jadeja, Alberto Cuesta Cañada, Señor Doggo,\r\n/// \"EIP-4626: Tokenized Vault Standard,\" Ethereum Improvement Proposals, no.\r\n/// 4626, December 2021. [Online serial].\r\n/// Available: https://eips.ethereum.org/EIPS/eip-4626.\r\ninterface IERC4626 {\r\n    /// Caller has exchanged assets for shares, and transferred those shares to\r\n    /// owner.\r\n    /// MUST be emitted when tokens are deposited into the Vault via the mint\r\n    /// and deposit methods.\r\n    /// @param caller `msg.sender` depositing assets for shares.\r\n    /// @param owner recipient of the newly minted shares.\r\n    /// @param assets amount of assets deposited.\r\n    /// @param shares amount of shares minted and sent to owner.\r\n    event Deposit(\r\n        address indexed caller,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /// Caller has exchanged shares, owned by owner, for assets, and\r\n    /// transferred those assets to receiver.\r\n    /// MUST be emitted when shares are withdrawn from the Vault in\r\n    /// ERC4626.redeem or ERC4626.withdraw methods.\r\n    /// @param caller `msg.sender` initiating the withdraw.\r\n    /// @param receiver recipient of withdrawn assets.\r\n    /// @param owner owner of shares burned to withdraw assets.\r\n    /// @param assets amount of assets withdrawn and sent to receiver.\r\n    /// @param shares amount of shares burned from owner.\r\n    event Withdraw(\r\n        address indexed caller,\r\n        address indexed receiver,\r\n        address indexed owner,\r\n        uint256 assets,\r\n        uint256 shares\r\n    );\r\n\r\n    /// The address of the underlying token used for the Vault for accounting,\r\n    /// depositing, and withdrawing.\r\n    /// MUST be an ERC-20 token contract.\r\n    /// MUST NOT revert.\r\n    /// @return assetTokenAddress address of the asset token.\r\n    function asset() external view returns (address assetTokenAddress);\r\n\r\n    /// Total amount of the underlying asset that is “managed” by Vault.\r\n    /// SHOULD include any compounding that occurs from yield.\r\n    /// MUST be inclusive of any fees that are charged against assets in the\r\n    /// Vault.\r\n    /// MUST NOT revert.\r\n    /// @return totalManagedAssets all assets in the vault including those that\r\n    /// cannot be withdrawn with shares due to fees or were never deposited,\r\n    /// perhaps due to fee accruals, etc.\r\n    function totalAssets() external view returns (uint256 totalManagedAssets);\r\n\r\n    /// The amount of shares that the Vault would exchange for the amount of\r\n    /// assets provided, in an ideal scenario where all the conditions are met.\r\n    /// MUST NOT be inclusive of any fees that are charged against assets in\r\n    /// the Vault.\r\n    /// MUST NOT show any variations depending on the caller.\r\n    /// MUST NOT reflect slippage or other on-chain conditions, when performing\r\n    /// the actual exchange.\r\n    /// MUST NOT revert unless due to integer overflow caused by an\r\n    /// unreasonably large input.\r\n    /// MUST round down towards 0.\r\n    /// This calculation MAY NOT reflect the “per-user” price-per-share, and\r\n    /// instead should reflect the “average-user’s” price-per-share, meaning\r\n    /// what the average user should expect to see when exchanging to and from.\r\n    /// @param assets amount of assets that would hypothetically be converted\r\n    /// to shares (minting) upon deposit.\r\n    /// @return shares amount of shares that hypothetically would be minted upon\r\n    /// deposit of given amount of assets.\r\n    function convertToShares(uint256 assets)\r\n        external\r\n        view\r\n        returns (uint256 shares);\r\n\r\n    /// The amount of assets that the Vault would exchange for the amount of\r\n    /// shares provided, in an ideal scenario where all the conditions are met.\r\n    /// MUST NOT be inclusive of any fees that are charged against assets in\r\n    /// the Vault.\r\n    /// MUST NOT show any variations depending on the caller.\r\n    /// MUST NOT reflect slippage or other on-chain conditions, when performing\r\n    /// the actual exchange.\r\n    /// MUST NOT revert unless due to integer overflow caused by an\r\n    /// unreasonably large input.\r\n    /// MUST round down towards 0.\r\n    /// This calculation MAY NOT reflect the “per-user” price-per-share, and\r\n    /// instead should reflect the “average-user’s” price-per-share, meaning\r\n    /// what the average user should expect to see when exchanging to and from.\r\n    /// @param shares amount of shares that would hypothetically be converted\r\n    /// (burned) to assets upon withdrawal.\r\n    /// @return assets amount of assets that would hypothetically be released\r\n    /// from the vault when given amount of shares were burned.\r\n    function convertToAssets(uint256 shares)\r\n        external\r\n        view\r\n        returns (uint256 assets);\r\n\r\n    /// Maximum amount of the underlying asset that can be deposited into the\r\n    /// Vault for the receiver, through a deposit call.\r\n    /// MUST return the maximum amount of assets deposit would allow to be\r\n    /// deposited for receiver and not cause a revert, which MUST NOT be higher\r\n    /// than the actual maximum that would be accepted (it should underestimate\r\n    /// if necessary). This assumes that the user has infinite assets,\r\n    /// i.e. MUST NOT rely on balanceOf of asset.\r\n    /// MUST factor in both global and user-specific limits, like if deposits\r\n    /// are entirely disabled (even temporarily) it MUST return 0.\r\n    /// MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of\r\n    /// assets that may be deposited.\r\n    /// MUST NOT revert.\r\n    /// @param receiver the receiver of hypothetical newly minted shares, were\r\n    /// a deposit to be processed.\r\n    /// @return maxAssets the maximum assets the receiver could deposit and\r\n    /// successfully receive shares.\r\n    function maxDeposit(address receiver)\r\n        external\r\n        view\r\n        returns (uint256 maxAssets);\r\n\r\n    /// Allows an on-chain or off-chain user to simulate the effects of their\r\n    /// deposit at the current block, given current on-chain conditions.\r\n    /// MUST return as close to and no more than the exact amount of Vault\r\n    /// shares that would be minted in a deposit call in the same transaction.\r\n    /// I.e. deposit should return the same or more shares as previewDeposit if\r\n    /// called in the same transaction.\r\n    /// MUST NOT account for deposit limits like those returned from maxDeposit\r\n    /// and should always act as though the deposit would be accepted,\r\n    /// regardless if the user has enough tokens approved, etc.\r\n    /// MUST be inclusive of deposit fees. Integrators should be aware of the\r\n    /// existence of deposit fees.\r\n    /// MUST NOT revert due to vault specific user/global limits. MAY revert\r\n    /// due to other conditions that would also cause deposit to revert.\r\n    /// Note that any unfavorable discrepancy between convertToShares and\r\n    /// previewDeposit SHOULD be considered slippage in share price or some\r\n    /// other type of condition, meaning the depositor will lose assets by\r\n    /// depositing.\r\n    /// @param assets amount of assets the `msg.sender` would hypothetically\r\n    /// deposit for shares.\r\n    /// @return shares amount of shares that would hypothetically be minted for\r\n    /// the `msg.sender`. MAY differ from `convertToShares` as\r\n    /// \"the average user\" could receive different shares to any specific user.\r\n    function previewDeposit(uint256 assets)\r\n        external\r\n        view\r\n        returns (uint256 shares);\r\n\r\n    /// Mints shares Vault shares to receiver by depositing exactly amount of\r\n    /// underlying tokens.\r\n    /// MUST emit the Deposit event.\r\n    /// MUST support ERC-20 approve / transferFrom on asset as a deposit flow.\r\n    /// MAY support an additional flow in which the underlying tokens are owned\r\n    /// by the Vault contract before the deposit execution, and are accounted\r\n    /// for during deposit.\r\n    /// MUST revert if all of assets cannot be deposited (due to deposit limit\r\n    /// being reached, slippage, the user not approving enough underlying\r\n    /// tokens to the Vault contract, etc).\r\n    /// Note that most implementations will require pre-approval of the Vault\r\n    /// with the Vault’s underlying asset token.\r\n    /// @param assets amount of assets the `msg.sender` is depositing.\r\n    /// @param receiver recipient of the newly minted shares.\r\n    /// @return shares amount of newly minted shares for recipient.\r\n    function deposit(uint256 assets, address receiver)\r\n        external\r\n        returns (uint256 shares);\r\n\r\n    /// Maximum amount of shares that can be minted from the Vault for the\r\n    /// receiver, through a mint call.\r\n    /// MUST return the maximum amount of shares mint would allow to be\r\n    /// deposited to receiver and not cause a revert, which MUST NOT be higher\r\n    /// than the actual maximum that would be accepted (it should underestimate\r\n    /// if necessary). This assumes that the user has infinite assets,\r\n    /// i.e. MUST NOT rely on balanceOf of asset.\r\n    /// MUST factor in both global and user-specific limits, like if mints are\r\n    /// entirely disabled (even temporarily) it MUST return 0.\r\n    /// MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of\r\n    /// shares that may be minted.\r\n    /// MUST NOT revert.\r\n    /// @param receiver hypothetical receiver of newly minted shares for\r\n    /// depositing assets.\r\n    /// @return maxShares maximum shares hypothetically mintable for the\r\n    /// receiver for a successful deposit.\r\n    function maxMint(address receiver)\r\n        external\r\n        view\r\n        returns (uint256 maxShares);\r\n\r\n    /// Allows an on-chain or off-chain user to simulate the effects of their\r\n    /// mint at the current block, given current on-chain conditions.\r\n    /// MUST return as close to and no fewer than the exact amount of assets\r\n    /// that would be deposited in a mint call in the same transaction.\r\n    /// I.e. mint should return the same or fewer assets as previewMint if\r\n    /// called in the same transaction.\r\n    /// MUST NOT account for mint limits like those returned from maxMint and\r\n    /// should always act as though the mint would be accepted, regardless if\r\n    /// the user has enough tokens approved, etc.\r\n    /// MUST be inclusive of deposit fees. Integrators should be aware of the\r\n    /// existence of deposit fees.\r\n    /// MUST NOT revert due to vault specific user/global limits. MAY revert\r\n    /// due to other conditions that would also cause mint to revert.\r\n    /// Note that any unfavorable discrepancy between convertToAssets and\r\n    /// previewMint SHOULD be considered slippage in share price or some other\r\n    /// type of condition, meaning the depositor will lose assets by minting.\r\n    /// @param shares amount of shares to hypothetically mint for `msg.sender`.\r\n    /// MAY differ from `convertToShares` as \"the average user\" may differ from\r\n    /// any specific user.\r\n    /// @return assets amount of assets that would hypothetically be desposited\r\n    /// for receiver to receive the given amount of shares.\r\n    function previewMint(uint256 shares) external view returns (uint256 assets);\r\n\r\n    /// Mints exactly shares Vault shares to receiver by depositing amount of\r\n    /// underlying tokens.\r\n    /// MUST emit the Deposit event.\r\n    /// MUST support ERC-20 approve / transferFrom on asset as a mint flow. MAY\r\n    /// support an additional flow in which the underlying tokens are owned by\r\n    /// the Vault contract before the mint execution, and are accounted for\r\n    /// during mint.\r\n    /// MUST revert if all of shares cannot be minted (due to deposit limit\r\n    /// being reached, slippage, the user not approving enough underlying\r\n    /// tokens to the Vault contract, etc).\r\n    /// Note that most implementations will require pre-approval of the Vault\r\n    /// with the Vault’s underlying asset token.\r\n    /// @param shares amount of shares to mint for receiver.\r\n    /// @param receiver address that will receive newly minted shares.\r\n    /// @return assets amount of assets that were deposited to mint shares.\r\n    function mint(uint256 shares, address receiver)\r\n        external\r\n        returns (uint256 assets);\r\n\r\n    /// Maximum amount of the underlying asset that can be withdrawn from the\r\n    /// owner balance in the Vault, through a withdraw call.\r\n    /// MUST return the maximum amount of assets that could be transferred from\r\n    /// owner through withdraw and not cause a revert, which MUST NOT be higher\r\n    /// than the actual maximum that would be accepted (it should underestimate\r\n    /// if necessary).\r\n    /// MUST factor in both global and user-specific limits, like if\r\n    /// withdrawals are entirely disabled (even temporarily) it MUST return 0.\r\n    /// MUST NOT revert.\r\n    /// @param owner the owner of the shares that would hypothetically be\r\n    /// burned to process a withdrawal.\r\n    /// @return maxAssets the maximum amount of assets that could\r\n    /// hypothetically be withdrawn by burning the owner's shares.\r\n    function maxWithdraw(address owner)\r\n        external\r\n        view\r\n        returns (uint256 maxAssets);\r\n\r\n    /// Allows an on-chain or off-chain user to simulate the effects of their\r\n    /// withdrawal at the current block, given current on-chain conditions.\r\n    /// MUST return as close to and no fewer than the exact amount of Vault\r\n    /// shares that would be burned in a withdraw call in the same transaction.\r\n    /// I.e. withdraw should return the same or fewer shares as previewWithdraw\r\n    /// if called in the same transaction.\r\n    /// MUST NOT account for withdrawal limits like those returned from\r\n    /// maxWithdraw and should always act as though the withdrawal would be\r\n    /// accepted, regardless if the user has enough shares, etc.\r\n    /// MUST be inclusive of withdrawal fees. Integrators should be aware of\r\n    /// the existence of withdrawal fees.\r\n    /// MUST NOT revert due to vault specific user/global limits. MAY revert\r\n    /// due to other conditions that would also cause withdraw to revert.\r\n    /// Note that any unfavorable discrepancy between convertToShares and\r\n    /// previewWithdraw SHOULD be considered slippage in share price or some\r\n    /// other type of condition, meaning the depositor will lose assets by\r\n    /// depositing.\r\n    /// @param assets amount of assets hypothetically being withdrawn by\r\n    /// `msg.sender` by burning their shares.\r\n    /// @return shares amount of shares that would be burned to withdraw the\r\n    /// given amount of assets.\r\n    function previewWithdraw(uint256 assets)\r\n        external\r\n        view\r\n        returns (uint256 shares);\r\n\r\n    /// Burns shares from owner and sends exactly assets of underlying tokens\r\n    /// to receiver.\r\n    /// MUST emit the Withdraw event.\r\n    /// MUST support a withdraw flow where the shares are burned from owner\r\n    /// directly where owner is msg.sender or msg.sender has ERC-20 approval\r\n    /// over the shares of owner. MAY support an additional flow in which the\r\n    /// shares are transferred to the Vault contract before the withdraw\r\n    /// execution, and are accounted for during withdraw.\r\n    /// MUST revert if all of assets cannot be withdrawn\r\n    /// (due to withdrawal limit being reached, slippage, the owner not having\r\n    /// enough shares, etc).\r\n    /// Note that some implementations will require pre-requesting to the Vault\r\n    /// before a withdrawal may be performed. Those methods should be performed\r\n    /// separately.\r\n    /// @param assets amount of assets to withdraw by burning owner's shares.\r\n    /// @param receiver withdrawn assets will be sent to receiver.\r\n    /// @param owner shares will be burned from owner to withdraw assets.\r\n    /// @return shares amount of shares that were burned from owner to process\r\n    /// the withdrawal.\r\n    function withdraw(\r\n        uint256 assets,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 shares);\r\n\r\n    /// Maximum amount of Vault shares that can be redeemed from the owner\r\n    /// balance in the Vault, through a redeem call.\r\n    /// MUST return the maximum amount of shares that could be transferred from\r\n    /// owner through redeem and not cause a revert, which MUST NOT be higher\r\n    /// than the actual maximum that would be accepted (it should underestimate\r\n    /// if necessary).\r\n    /// MUST factor in both global and user-specific limits, like if redemption\r\n    /// is entirely disabled (even temporarily) it MUST return 0.\r\n    /// MUST NOT revert.\r\n    /// @param owner hypothetical share owner who is redeeming (burning) shares\r\n    /// for asset withdrawal.\r\n    /// @return maxShares maximum hypothetical shares that could be burned by\r\n    /// the owner to withdraw assets.\r\n    function maxRedeem(address owner) external view returns (uint256 maxShares);\r\n\r\n    /// Allows an on-chain or off-chain user to simulate the effects of their\r\n    /// redeemption at the current block, given current on-chain conditions.\r\n    /// MUST return as close to and no more than the exact amount of assets\r\n    /// that would be withdrawn in a redeem call in the same transaction.\r\n    /// I.e. redeem should return the same or more assets as previewRedeem if\r\n    /// called in the same transaction.\r\n    /// MUST NOT account for redemption limits like those returned from\r\n    /// maxRedeem and should always act as though the redemption would be\r\n    /// accepted, regardless if the user has enough shares, etc.\r\n    /// MUST be inclusive of withdrawal fees. Integrators should be aware of\r\n    /// the existence of withdrawal fees.\r\n    /// MUST NOT revert due to vault specific user/global limits. MAY revert\r\n    /// due to other conditions that would also cause redeem to revert.\r\n    /// Note that any unfavorable discrepancy between convertToAssets and\r\n    /// previewRedeem SHOULD be considered slippage in share price or some\r\n    /// other type of condition, meaning the depositor will lose assets by\r\n    /// redeeming.\r\n    /// @param shares amount of shares that would hypothetically be burned by\r\n    /// `msg.sender` to withdraw assets.\r\n    /// @return assets amount of assets that would hypothetically be withdrawn\r\n    /// for recipient when burning given amount of owner's shares.\r\n    function previewRedeem(uint256 shares)\r\n        external\r\n        view\r\n        returns (uint256 assets);\r\n\r\n    /// Burns exactly shares from owner and sends assets of underlying tokens\r\n    /// to receiver.\r\n    /// MUST emit the Withdraw event.\r\n    /// MUST support a redeem flow where the shares are burned from owner\r\n    /// directly where owner is msg.sender or msg.sender has ERC-20 approval\r\n    /// over the shares of owner. MAY support an additional flow in which the\r\n    /// shares are transferred to the Vault contract before the redeem\r\n    /// execution, and are accounted for during redeem.\r\n    /// MUST revert if all of shares cannot be redeemed\r\n    /// (due to withdrawal limit being reached, slippage, the owner not having\r\n    /// enough shares, etc).\r\n    /// Note that some implementations will require pre-requesting to the Vault\r\n    /// before a withdrawal may be performed. Those methods should be performed\r\n    /// separately.\r\n    /// @param shares amount of owner's shares to redeem (burn) to withdraw\r\n    /// assets for receiver.\r\n    /// @param receiver withdrawn assets will be sent to receiver.\r\n    /// @param owner owner's shares will be burned to process the withdrawal\r\n    /// of assets sent to receiver.\r\n    /// @return assets amount of assets withdrawn and sent to receiver.\r\n    function redeem(\r\n        uint256 shares,\r\n        address receiver,\r\n        address owner\r\n    ) external returns (uint256 assets);\r\n}\r\n"
    },
    "./contracts/oracle/price/chainlink/ChainlinkFeedPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity =0.8.10;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport \"@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\n\r\nimport \"../IPriceOracle.sol\";\r\n\r\n/// All data required to construct the contract.\r\n/// @param feed The address of the underlying chainlink oracle.\r\n/// @param staleAfter The duration after which price data will be considered\r\n/// too stale for use and error.\r\nstruct ConstructionConfig {\r\n    address feed;\r\n    uint256 staleAfter;\r\n}\r\n\r\n/// @title ChainlinkFeedPriceOracle\r\n/// @notice Converts a single chainlink price oracle to an `IPriceOracle`.\r\n/// This involves:\r\n/// - Fetching latest round data from chainlink\r\n/// - Rejecting negative price values\r\n/// - Fetching decimals from chainlink\r\n/// - Rescaling chainlink price data to target decimals if required\r\ncontract ChainlinkFeedPriceOracle is IPriceOracle {\r\n    using SafeCast for int256;\r\n    using FixedPointMath for uint256;\r\n\r\n    /// Emitted upon deployment and construction of oracle\r\n    /// @param sender `msg.sender` that deploys the oracle.\r\n    /// @param config All config used to construct the contract.\r\n    event Construction(address sender, ConstructionConfig config);\r\n\r\n    /// Immutable copy of `ConstructionConfig.feed`.\r\n    AggregatorV3Interface public immutable feed;\r\n\r\n    /// Immutable copy of `ConstructionConfig.staleAfter`.\r\n    uint256 public immutable staleAfter;\r\n\r\n    /// Constructor.\r\n    /// @param config_ All config required to construct the contract.\r\n    constructor(ConstructionConfig memory config_) {\r\n        feed = AggregatorV3Interface(config_.feed);\r\n        staleAfter = config_.staleAfter;\r\n        emit Construction(msg.sender, config_);\r\n    }\r\n\r\n    /// @inheritdoc IPriceOracle\r\n    function price() external view override returns (uint256 price_) {\r\n        (, int256 answer_, , uint256 updatedAt_, ) = feed.latestRoundData();\r\n        require(answer_ > 0, \"MIN_BASE_PRICE\");\r\n        // Checked time comparison ensures no updates from the future as that\r\n        // would overflow, and no stale prices.\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(block.timestamp - updatedAt_ < staleAfter, \"STALE_PRICE\");\r\n\r\n        // Safely cast the answer to uint and scale it to 18 decimal FP.\r\n        price_ = answer_.toUint256().scale18(feed.decimals());\r\n    }\r\n}\r\n"
    },
    "./contracts/oracle/price/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity ^0.8.0;\r\n\r\n/// Simplified interface into a price oracle.\r\n/// The intention is that some more complex oracle interface such as chainlink\r\n/// `AggregatorV3Interface` is wrapped/adapted by a contract that implements\r\n/// `IPriceOracle` to produce a single final value.\r\n///\r\n/// Prices from an `IPriceOracle` MUST be:\r\n/// - The latest available data/value\r\n/// - Fresh enough or error if only too-stale data is available\r\n/// - Represented as positive uint values only or error\r\n/// - 18 decimal fixed point values representing a ratio (price) between \"base\"\r\n/// and \"quote\" token.\r\n///\r\n/// If for any reason the underlying oracle cannot produce an appropriate\r\n/// answer it MUST error rather than return inappropriate values. The ability\r\n/// to do so MAY be limited by upstream providers (e.g. Chainlink silently\r\n/// pausing price data during a heartbeat).\r\nabstract contract IPriceOracle {\r\n    /// Returns the current/latest price according to the oracle.\r\n    function price() external view virtual returns (uint256 price_);\r\n}\r\n"
    },
    "./contracts/oracle/price/chainlink/ChainlinkFeedPriceOracleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.10;\r\n\r\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\r\nimport \"./ChainlinkFeedPriceOracle.sol\";\r\n\r\n/// @title ChainlinkFeedPriceOracleFactory\r\n/// @notice Factory for creating and deploying `ChainlinkFeedPriceOracle`.\r\ncontract ChainlinkFeedPriceOracleFactory is Factory {\r\n    /// @inheritdoc Factory\r\n    function _createChild(bytes calldata data_)\r\n        internal\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        // This is built directly with `new` instead of cloning as we're\r\n        // optimizing for use of cheap immutables at runtime rather than cheap\r\n        // deployments.\r\n        return\r\n            address(\r\n                new ChainlinkFeedPriceOracle(\r\n                    abi.decode(data_, (ConstructionConfig))\r\n                )\r\n            );\r\n    }\r\n\r\n    /// Typed wrapper for `createChild` with Source.\r\n    /// Use original `Factory` `createChild` function signature if function\r\n    /// parameters are already encoded.\r\n    ///\r\n    /// @param config_ construction configuration for the oracle.\r\n    /// @return New `ChainlinkFeedPriceOracle` child contract address.\r\n    function createChildTyped(ConstructionConfig memory config_)\r\n        external\r\n        returns (ChainlinkFeedPriceOracle)\r\n    {\r\n        return ChainlinkFeedPriceOracle(this.createChild(abi.encode(config_)));\r\n    }\r\n}\r\n"
    },
    "./contracts/oracle/price/TwoPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity =0.8.10;\r\n\r\nimport \"./IPriceOracle.sol\";\r\nimport \"@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol\";\r\n\r\n/// All config required for construction.\r\n/// @param base The base price of the merged pair, will be the numerator.\r\n/// @param quote The quote price of the merged pair, will be the denominator.\r\nstruct ConstructionConfig {\r\n    address base;\r\n    address quote;\r\n}\r\n\r\n/// @title TwoPriceOracle\r\n/// Any time we have two price feeds that share a denominator we can calculate\r\n/// a single price by dividing them.\r\n///\r\n/// For example, an ETH/USD (base) and an XAU/USD (quote) price can be combined\r\n/// to a single ETH/XAU price as (ETH/USD) / (XAU/USD).\r\ncontract TwoPriceOracle is IPriceOracle {\r\n    using FixedPointMath for uint256;\r\n\r\n    /// Emitted upon deployment and construction.\r\n    event Construction(address sender, ConstructionConfig config);\r\n\r\n    /// As per `ConstructionConfig.base`.\r\n    IPriceOracle public immutable base;\r\n    /// As per `ConstructionConfig.quote`.\r\n    IPriceOracle public immutable quote;\r\n\r\n    /// Constructor.\r\n    /// @param config_ All configr required to construct.\r\n    constructor(ConstructionConfig memory config_) {\r\n        base = IPriceOracle(config_.base);\r\n        quote = IPriceOracle(config_.quote);\r\n        emit Construction(msg.sender, config_);\r\n    }\r\n\r\n    /// Calculates the price as `base / quote`.\r\n    /// @inheritdoc IPriceOracle\r\n    function price() external view override returns (uint256 price_) {\r\n        price_ = base.price().fixedPointDiv(quote.price());\r\n    }\r\n}\r\n"
    },
    "./contracts/oracle/price/TwoPriceOracleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.10;\r\n\r\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\r\nimport \"./TwoPriceOracle.sol\";\r\n\r\n/// @title TwoPriceOracleFactory\r\n/// @notice Factory for creating and deploying `TwoPriceOracle`.\r\ncontract TwoPriceOracleFactory is Factory {\r\n    /// @inheritdoc Factory\r\n    function _createChild(bytes calldata data_)\r\n        internal\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        // This is built directly with `new` instead of cloning as we're\r\n        // optimizing for use of cheap immutables at runtime rather than cheap\r\n        // deployments.\r\n        return\r\n            address(\r\n                new TwoPriceOracle(abi.decode(data_, (ConstructionConfig)))\r\n            );\r\n    }\r\n\r\n    /// Typed wrapper for `createChild` with Source.\r\n    /// Use original `Factory` `createChild` function signature if function\r\n    /// parameters are already encoded.\r\n    ///\r\n    /// @param config_ Construction config for the oracle.\r\n    /// @return New `ChainlinkFeedPriceOracle` child contract address.\r\n    function createChildTyped(ConstructionConfig memory config_)\r\n        external\r\n        returns (TwoPriceOracle)\r\n    {\r\n        return TwoPriceOracle(this.createChild(abi.encode(config_)));\r\n    }\r\n}\r\n"
    },
    "./contracts/test/TestChainlinkDataFeed.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// Chainlink imports.\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\n\r\nstruct RoundData {\r\n    int256 answer;\r\n    uint256 startedAt;\r\n    uint256 updatedAt;\r\n    uint80 answeredInRound;\r\n}\r\n\r\ncontract TestChainlinkDataFeed is AggregatorV3Interface {\r\n    uint8 private _decimals;\r\n    string private _description;\r\n    mapping(uint80 => RoundData) private _roundData;\r\n    uint80 private _latestRoundId;\r\n    uint256 private _version;\r\n\r\n    function setDecimals(uint8 decimals_) public {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function setDescription(string memory description_) public {\r\n        _description = description_;\r\n    }\r\n\r\n    function setRoundData(uint80 roundId_, RoundData memory roundData_) public {\r\n        _roundData[roundId_] = roundData_;\r\n        // Treat this as the high water mark if appropriate.\r\n        if (roundId_ > _latestRoundId) {\r\n            _latestRoundId = roundId_;\r\n        }\r\n    }\r\n\r\n    function setVersion(uint256 version_) public {\r\n        _version = version_;\r\n    }\r\n\r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function description() public view override returns (string memory) {\r\n        return _description;\r\n    }\r\n\r\n    function getRoundData(uint80 roundId_)\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint80,\r\n            int256,\r\n            uint256,\r\n            uint256,\r\n            uint80\r\n        )\r\n    {\r\n        RoundData memory roundData_ = _roundData[roundId_];\r\n        return (\r\n            roundId_,\r\n            roundData_.answer,\r\n            roundData_.startedAt,\r\n            roundData_.updatedAt,\r\n            roundData_.answeredInRound\r\n        );\r\n    }\r\n\r\n    function latestRoundData()\r\n        public\r\n        view\r\n        override\r\n        returns (\r\n            uint80,\r\n            int256,\r\n            uint256,\r\n            uint256,\r\n            uint80\r\n        )\r\n    {\r\n        return getRoundData(_latestRoundId);\r\n    }\r\n\r\n    function version() public view override returns (uint256) {\r\n        return _version;\r\n    }\r\n}\r\n"
    },
    "./contracts/test/TestErc20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n// solhint-disable-next-line max-line-length\r\n\r\n/// @title Erc20Token\r\n/// A test token that can be used as a reserve asset.\r\n\r\ncontract TestErc20 is ERC20 {\r\n    /// Accounts to freeze during testing.\r\n\r\n    // Stables such as USDT and USDC commonly have 6 decimals.\r\n    uint256 public constant DECIMALS = 6;\r\n    // One _billion_ dollars .\r\n    uint256 public constant TOTAL_SUPPLY = 10**(DECIMALS + 9);\r\n\r\n    /// Define and mint the erc20 token.\r\n    constructor() ERC20(\"USD Classic\", \"USDCC\") {\r\n        _mint(msg.sender, TOTAL_SUPPLY);\r\n    }\r\n}\r\n"
    },
    "./contracts/test/TestPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../oracle/price/IPriceOracle.sol\";\r\n\r\ncontract TestPriceOracle is IPriceOracle {\r\n    uint256 private _price;\r\n\r\n    function setPrice(uint256 price_) public {\r\n        _price = price_;\r\n    }\r\n\r\n    function price() external view override returns (uint256) {\r\n        return _price;\r\n    }\r\n}\r\n"
    },
    "./contracts/vault/offchainAsset/OffchainAssetVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity =0.8.10;\r\n\r\nimport {ConstructionConfig as ReceiptVaultConstructionConfig, ReceiptVault, ERC1155} from \"../ReceiptVault.sol\";\r\nimport \"@openzeppelin/contracts/access/AccessControl.sol\";\r\n\r\nimport \"@beehiveinnovation/rain-protocol/contracts/tier/ITier.sol\";\r\nimport \"@beehiveinnovation/rain-protocol/contracts/tier/libraries/TierReport.sol\";\r\n\r\n/// All data required to construct `CertifiedAssetConnect`.\r\n/// @param admin The initial admin has ALL ROLES. It is up to the admin to\r\n/// appropriately delegate and renounce roles or to be a smart contract with\r\n/// formal governance processes. In general a single EOA holding all admin roles\r\n/// is completely insecure and counterproductive as it allows a single address\r\n/// to both mint and audit assets (and many other things).\r\n/// @param receiptConstructionConfig Forwarded to construction ReceiptVault.\r\nstruct ConstructionConfig {\r\n    address admin;\r\n    ReceiptVaultConstructionConfig receiptVaultConfig;\r\n}\r\n\r\ncontract OffchainAssetVault is ReceiptVault, AccessControl {\r\n    event OffchainAssetVaultConstruction(address sender, ConstructionConfig config);\r\n    event Certify(address sender, uint256 until, bytes data);\r\n    event ConfiscateShares(\r\n        address sender,\r\n        address confiscatee,\r\n        uint256 confiscated\r\n    );\r\n    event ConfiscateReceipt(\r\n        address sender,\r\n        address confiscatee,\r\n        uint256 id,\r\n        uint256 confiscated\r\n    );\r\n\r\n    bytes32 private constant DEPOSITOR = keccak256(\"DEPOSITOR\");\r\n    bytes32 private constant DEPOSITOR_ADMIN = keccak256(\"DEPOSITOR_ADMIN\");\r\n\r\n    bytes32 private constant WITHDRAWER = keccak256(\"WITHDRAWER\");\r\n    bytes32 private constant WITHDRAWER_ADMIN = keccak256(\"WITHDRAWER_ADMIN\");\r\n\r\n    bytes32 private constant CERTIFIER = keccak256(\"CERTIFIER\");\r\n    bytes32 private constant CERTIFIER_ADMIN = keccak256(\"CERTIFIER_ADMIN\");\r\n\r\n    bytes32 private constant HANDLER = keccak256(\"HANDLER\");\r\n    bytes32 private constant HANDLER_ADMIN = keccak256(\"HANDLER_ADMIN\");\r\n\r\n    bytes32 private constant ERC20TIERER = keccak256(\"ERC20TIERER\");\r\n    bytes32 private constant ERC20TIERER_ADMIN = keccak256(\"ERC20TIERER_ADMIN\");\r\n\r\n    bytes32 private constant ERC1155TIERER = keccak256(\"ERC1155TIERER\");\r\n    bytes32 private constant ERC1155TIERER_ADMIN =\r\n        keccak256(\"ERC1155TIERER_ADMIN\");\r\n\r\n    bytes32 private constant ERC20SNAPSHOTTER = keccak256(\"ERC20SNAPSHOTTER\");\r\n    bytes32 private constant ERC20SNAPSHOTTER_ADMIN =\r\n        keccak256(\"ERC20SNAPSHOTTER_ADMIN\");\r\n\r\n    bytes32 private constant CONFISCATOR = keccak256(\"CONFISCATOR\");\r\n    bytes32 private constant CONFISCATOR_ADMIN = keccak256(\"CONFISCATOR_ADMIN\");\r\n\r\n    uint256 private highwaterId;\r\n\r\n    uint256 private certifiedUntil;\r\n    ITier private erc20Tier;\r\n    uint256 private erc20MinimumTier;\r\n    ITier private erc1155Tier;\r\n    uint256 private erc1155MinimumTier;\r\n\r\n    constructor(ConstructionConfig memory config_)\r\n        ReceiptVault(config_.receiptVaultConfig)\r\n    {\r\n        // There is no asset, the asset is offchain.\r\n        require(\r\n            config_.receiptVaultConfig.asset == address(0),\r\n            \"NONZERO_ASSET\"\r\n        );\r\n\r\n        _setRoleAdmin(DEPOSITOR_ADMIN, DEPOSITOR_ADMIN);\r\n        _setRoleAdmin(DEPOSITOR, DEPOSITOR_ADMIN);\r\n\r\n        _setRoleAdmin(WITHDRAWER_ADMIN, WITHDRAWER_ADMIN);\r\n        _setRoleAdmin(WITHDRAWER, WITHDRAWER_ADMIN);\r\n\r\n        _setRoleAdmin(CERTIFIER_ADMIN, CERTIFIER_ADMIN);\r\n        _setRoleAdmin(CERTIFIER, CERTIFIER_ADMIN);\r\n\r\n        _setRoleAdmin(HANDLER_ADMIN, HANDLER_ADMIN);\r\n        _setRoleAdmin(HANDLER, HANDLER_ADMIN);\r\n\r\n        _setRoleAdmin(ERC20TIERER_ADMIN, ERC20TIERER_ADMIN);\r\n        _setRoleAdmin(ERC20TIERER, ERC20TIERER_ADMIN);\r\n\r\n        _setRoleAdmin(ERC1155TIERER_ADMIN, ERC1155TIERER_ADMIN);\r\n        _setRoleAdmin(ERC1155TIERER, ERC1155TIERER_ADMIN);\r\n\r\n        _setRoleAdmin(ERC20SNAPSHOTTER_ADMIN, ERC20SNAPSHOTTER_ADMIN);\r\n        _setRoleAdmin(ERC20SNAPSHOTTER, ERC20SNAPSHOTTER_ADMIN);\r\n\r\n        _setRoleAdmin(CONFISCATOR_ADMIN, CONFISCATOR_ADMIN);\r\n        _setRoleAdmin(CONFISCATOR, CONFISCATOR_ADMIN);\r\n\r\n        _grantRole(DEPOSITOR_ADMIN, config_.admin);\r\n        _grantRole(WITHDRAWER_ADMIN, config_.admin);\r\n        _grantRole(CERTIFIER_ADMIN, config_.admin);\r\n        _grantRole(HANDLER_ADMIN, config_.admin);\r\n        _grantRole(ERC20TIERER_ADMIN, config_.admin);\r\n        _grantRole(ERC1155TIERER_ADMIN, config_.admin);\r\n        _grantRole(ERC20SNAPSHOTTER_ADMIN, config_.admin);\r\n        _grantRole(CONFISCATOR_ADMIN, config_.admin);\r\n\r\n        emit OffchainAssetVaultConstruction(msg.sender, config_);\r\n    }\r\n\r\n    function _beforeDeposit(\r\n        uint256,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) internal view override {\r\n        require(hasRole(DEPOSITOR, msg.sender), \"NOT_DEPOSITOR\");\r\n    }\r\n\r\n    function _afterWithdraw(\r\n        uint256,\r\n        address,\r\n        address owner_,\r\n        uint256,\r\n        uint256\r\n    ) internal view override {\r\n        require(hasRole(WITHDRAWER, owner_), \"NOT_WITHDRAWER\");\r\n    }\r\n\r\n    /// Shares total supply is 1:1 with offchain assets.\r\n    /// Assets aren't real so only way to report this is to return the total\r\n    /// supply of shares.\r\n    /// @inheritdoc ReceiptVault\r\n    function totalAssets()\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 totalManagedAssets_)\r\n    {\r\n        totalManagedAssets_ = totalSupply();\r\n    }\r\n\r\n    function _shareRatio(address depositor_, address)\r\n        internal\r\n        view\r\n        override\r\n        returns (uint256 shareRatio_)\r\n    {\r\n        shareRatio_ = hasRole(DEPOSITOR, depositor_) ? _shareRatio() : 0;\r\n    }\r\n\r\n    /// Offchain assets are always deposited 1:1 with shares.\r\n    /// @inheritdoc ReceiptVault\r\n    function previewDeposit(uint256 assets_)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 shares_)\r\n    {\r\n        shares_ = hasRole(DEPOSITOR, msg.sender) ? assets_ : 0;\r\n    }\r\n\r\n    function previewWithdraw(uint256 assets_, uint256 id_)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 shares_)\r\n    {\r\n        shares_ = hasRole(WITHDRAWER, msg.sender)\r\n            ? super.previewWithdraw(assets_, id_)\r\n            : 0;\r\n    }\r\n\r\n    function previewMint(uint256 shares_)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 assets_)\r\n    {\r\n        assets_ = hasRole(DEPOSITOR, msg.sender)\r\n            ? super.previewMint(shares_)\r\n            : 0;\r\n    }\r\n\r\n    function previewRedeem(uint256 shares_, uint256 id_)\r\n        public\r\n        view\r\n        override\r\n        returns (uint256 assets_)\r\n    {\r\n        assets_ = hasRole(WITHDRAWER, msg.sender)\r\n            ? super.previewRedeem(shares_, id_)\r\n            : 0;\r\n    }\r\n\r\n    function _nextId() internal override returns (uint256 id_) {\r\n        id_ = highwaterId + 1;\r\n        highwaterId = id_;\r\n    }\r\n\r\n    function _beforeReceiptInformation(uint256 id_, bytes memory)\r\n        internal\r\n        view\r\n        override\r\n    {\r\n        // Only receipt holders and certifiers can assert things about offchain\r\n        // assets.\r\n        require(\r\n            balanceOf(msg.sender, id_) > 0 || hasRole(CERTIFIER, msg.sender),\r\n            \"ASSET_INFORMATION_AUTH\"\r\n        );\r\n    }\r\n\r\n    /// Receipt holders who are also depositors can increase the deposit amount\r\n    /// for the existing id of this receipt. It is STRONGLY RECOMMENDED the\r\n    /// redepositor also provides data to be forwarded to asset information to\r\n    /// justify the additional deposit. New offchain assets MUST NOT redeposit\r\n    /// under existing IDs, deposit under a new id instead.\r\n    /// @param assets_ As per IERC4626 `deposit`.\r\n    /// @param receiver_ As per IERC4626 `deposit`.\r\n    /// @param id_ The existing receipt to despoit additional assets under. Will\r\n    /// mint new ERC20 shares and also increase the held receipt amount 1:1.\r\n    /// @param receiptInformation_ Forwarded to receipt mint and\r\n    /// `receiptInformation`.\r\n    function redeposit(\r\n        uint256 assets_,\r\n        address receiver_,\r\n        uint256 id_,\r\n        bytes calldata receiptInformation_\r\n    ) external returns (uint256 shares_) {\r\n        require(balanceOf(msg.sender, id_) > 0, \"NOT_RECEIPT_HOLDER\");\r\n        _deposit(\r\n            assets_,\r\n            receiver_,\r\n            _shareRatio(msg.sender, receiver_),\r\n            id_,\r\n            receiptInformation_\r\n        );\r\n        shares_ = assets_;\r\n    }\r\n\r\n    /// Needed here to fix Open Zeppelin implementing `supportsInterface` on\r\n    /// multiple base contracts.\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC1155, AccessControl)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function snapshot() external onlyRole(ERC20SNAPSHOTTER) returns (uint256) {\r\n        return _snapshot();\r\n    }\r\n\r\n    /// @param tier_ `ITier` contract to check reports from. MAY be `0` to\r\n    /// disable report checking.\r\n    /// @param minimumTier_ The minimum tier to be held according to `tier_`.\r\n    function setERC20Tier(address tier_, uint256 minimumTier_)\r\n        external\r\n        onlyRole(ERC20TIERER)\r\n    {\r\n        erc20Tier = ITier(tier_);\r\n        erc20MinimumTier = minimumTier_;\r\n    }\r\n\r\n    /// @param tier_ `ITier` contract to check reports from. MAY be `0` to\r\n    /// disable report checking.\r\n    /// @param minimumTier_ The minimum tier to be held according to `tier_`.\r\n    function setERC1155Tier(address tier_, uint256 minimumTier_)\r\n        external\r\n        onlyRole(ERC1155TIERER)\r\n    {\r\n        erc1155Tier = ITier(tier_);\r\n        erc1155MinimumTier = minimumTier_;\r\n    }\r\n\r\n    function certify(\r\n        uint256 until_,\r\n        bytes calldata data_,\r\n        bool forceUntil_\r\n    ) external onlyRole(CERTIFIER) {\r\n        // A certifier can set `forceUntil_` to true to force a _decrease_ in\r\n        // the `certifiedUntil` time, which is unusual but MAY need to be done\r\n        // in the case of rectifying a prior mistake.\r\n        if (forceUntil_ || until_ > certifiedUntil) {\r\n            certifiedUntil = until_;\r\n        }\r\n        emit Certify(msg.sender, until_, data_);\r\n    }\r\n\r\n    function enforceValidTransfer(\r\n        ITier tier_,\r\n        uint256 minimumTier_,\r\n        address from_,\r\n        address to_\r\n    ) internal view {\r\n        // Handlers can ALWAYS send and receive funds.\r\n        // Handlers bypass BOTH the timestamp on certification AND tier based\r\n        // restriction.\r\n        if (hasRole(HANDLER, from_) || hasRole(HANDLER, to_)) {\r\n            return;\r\n        }\r\n\r\n        // Minting and burning is always allowed as it is controlled via. RBAC\r\n        // separately to the tier contracts. Minting and burning is ALSO valid\r\n        // after the certification expires as it is likely the only way to\r\n        // repair the system and bring it back to a certifiable state.\r\n        if (from_ == address(0) || to_ == address(0)) {\r\n            return;\r\n        }\r\n\r\n        // Confiscation is always allowed as it likely represents some kind of\r\n        // regulatory/legal requirement. It may also be required to satisfy\r\n        // certification requirements.\r\n        if (hasRole(CONFISCATOR, to_)) {\r\n            return;\r\n        }\r\n\r\n        // Everyone else can only transfer while the certification is valid.\r\n        //solhint-disable-next-line not-rely-on-time\r\n        require(block.timestamp <= certifiedUntil, \"CERTIFICATION_EXPIRED\");\r\n\r\n        // If there is a tier contract we enforce it.\r\n        if (address(tier_) != address(0) && minimumTier_ > 0) {\r\n            // The sender must have a valid tier.\r\n            require(\r\n                block.number >=\r\n                    TierReport.tierBlock(tier_.report(from_), minimumTier_),\r\n                \"SENDER_TIER\"\r\n            );\r\n            // The recipient must have a valid tier.\r\n            require(\r\n                block.number >=\r\n                    TierReport.tierBlock(tier_.report(to_), minimumTier_),\r\n                \"RECIPIENT_TIER\"\r\n            );\r\n        }\r\n    }\r\n\r\n    // @inheritdoc ERC20\r\n    function _beforeTokenTransfer(\r\n        address from_,\r\n        address to_,\r\n        uint256\r\n    ) internal view override {\r\n        enforceValidTransfer(erc20Tier, erc20MinimumTier, from_, to_);\r\n    }\r\n\r\n    // @inheritdoc ERC1155\r\n    function _beforeTokenTransfer(\r\n        address,\r\n        address from_,\r\n        address to_,\r\n        uint256[] memory,\r\n        uint256[] memory,\r\n        bytes memory\r\n    ) internal view override {\r\n        enforceValidTransfer(erc1155Tier, erc1155MinimumTier, from_, to_);\r\n    }\r\n\r\n    function confiscate(address confiscatee_)\r\n        external\r\n        nonReentrant\r\n        onlyRole(CONFISCATOR)\r\n        returns (uint256 confiscated_)\r\n    {\r\n        if (\r\n            address(erc20Tier) == address(0) ||\r\n            block.number <\r\n            TierReport.tierBlock(\r\n                erc20Tier.report(confiscatee_),\r\n                erc20MinimumTier\r\n            )\r\n        ) {\r\n            confiscated_ = balanceOf(confiscatee_);\r\n            if (confiscated_ > 0) {\r\n                _transfer(confiscatee_, msg.sender, confiscated_);\r\n            }\r\n        }\r\n        emit ConfiscateShares(msg.sender, confiscatee_, confiscated_);\r\n    }\r\n\r\n    function confiscate(address confiscatee_, uint256 id_)\r\n        external\r\n        nonReentrant\r\n        onlyRole(CONFISCATOR)\r\n        returns (uint256 confiscated_)\r\n    {\r\n        if (\r\n            address(erc1155Tier) == address(0) ||\r\n            block.number <\r\n            TierReport.tierBlock(\r\n                erc1155Tier.report(confiscatee_),\r\n                erc1155MinimumTier\r\n            )\r\n        ) {\r\n            confiscated_ = balanceOf(confiscatee_, id_);\r\n            if (confiscated_ > 0) {\r\n                _safeTransferFrom(\r\n                    confiscatee_,\r\n                    msg.sender,\r\n                    id_,\r\n                    confiscated_,\r\n                    \"\"\r\n                );\r\n            }\r\n        }\r\n        emit ConfiscateReceipt(msg.sender, confiscatee_, id_, confiscated_);\r\n    }\r\n}\r\n"
    },
    "./contracts/vault/ReceiptVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity =0.8.10;\r\n\r\nimport {ERC20, ERC20Snapshot} from \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\nimport \"../erc4626/IERC4626.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\r\n\r\nstruct ConstructionConfig {\r\n    address asset;\r\n    string name;\r\n    string symbol;\r\n    string uri;\r\n}\r\n\r\ncontract ReceiptVault is\r\n    ERC20Snapshot,\r\n    ERC1155,\r\n    IERC4626,\r\n    ReentrancyGuard,\r\n    Multicall\r\n{\r\n    using FixedPointMath for uint256;\r\n    using SafeERC20 for IERC20;\r\n\r\n    /// Emitted when deployed and constructed.\r\n    /// @param sender `msg.sender` that deployed the contract.\r\n    /// @param config All construction config.\r\n    event Construction(address sender, ConstructionConfig config);\r\n    event ReceiptInformation(address sender, uint256 id, bytes data);\r\n\r\n    address private immutable _asset;\r\n\r\n    /// Users MAY OPTIONALLY set minimum prices for 4626 deposits. Alternatively\r\n    /// they MAY avoid the gas cost of modifying storage and call the\r\n    /// non-standard equivalent functions that take a minimum price parameter.\r\n    mapping(address => uint256) public minShareRatios;\r\n\r\n    /// Users MAY OPTIONALLY set the receipt price they want to withdraw as a\r\n    /// two step workflow and call the 4626 standard withdraw functions.\r\n    /// Alternatively they MAY avoid the gas cost of modifying storage and call\r\n    /// the non-standard equivalent functions that take a price parameter.\r\n    mapping(address => uint256) public withdrawIds;\r\n\r\n    constructor(ConstructionConfig memory config_)\r\n        ERC20(config_.name, config_.symbol)\r\n        ERC1155(config_.uri)\r\n    {\r\n        _asset = config_.asset;\r\n    }\r\n\r\n    /// Calculate how many shares_ will be minted in return for assets_.\r\n    /// @param assets_ Amount of assets being deposited.\r\n    /// @param price_ The oracle price to deposit against.\r\n    /// @param minPrice_ The minimum price required by the depositor. Will\r\n    /// error if `price_` is less than `minPrice_`.\r\n    /// @return shares_ Amount of shares to mint for this deposit.\r\n    function _calculateDeposit(\r\n        uint256 assets_,\r\n        uint256 price_,\r\n        uint256 minPrice_\r\n    ) internal pure returns (uint256 shares_) {\r\n        require(price_ >= minPrice_, \"MIN_PRICE\");\r\n        // IRC4626:\r\n        // If (1) it’s calculating how many shares to issue to a user for a\r\n        // certain amount of the underlying tokens they provide, it should\r\n        // round down.\r\n        shares_ = assets_.fixedPointMul(price_);\r\n    }\r\n\r\n    /// Calculate how many assets_ are needed to mint shares_.\r\n    /// @param shares_ Amount of shares desired to be minted.\r\n    /// @param shareRatio_ The ratio shares are minted at per asset.\r\n    /// @param minShareRatio_ The minimum ratio required by the minter. Will\r\n    /// error if `shareRatio_` is less than `minShareRatio_`.\r\n    /// @return assets_ Amount of assets that must be deposited for this mint.\r\n    function _calculateMint(\r\n        uint256 shares_,\r\n        uint256 shareRatio_,\r\n        uint256 minShareRatio_\r\n    ) internal pure returns (uint256 assets_) {\r\n        require(shareRatio_ >= minShareRatio_, \"MIN_SHARE_RATIO\");\r\n        // IERC4626:\r\n        // If (2) it’s calculating the amount of underlying tokens a user has\r\n        // to provide to receive a certain amount of shares, it should\r\n        // round up.\r\n        assets_ = shares_.fixedPointDiv(shareRatio_) + 1;\r\n    }\r\n\r\n    /// Calculate how many shares_ to burn to withdraw assets_.\r\n    /// @param assets_ Amount of assets being withdrawn.\r\n    /// @param price_ Oracle price to withdraw against.\r\n    /// @return shares_ Amount of shares to burn for this withdrawal.\r\n    function _calculateWithdraw(uint256 assets_, uint256 price_)\r\n        internal\r\n        pure\r\n        returns (uint256 shares_)\r\n    {\r\n        // IERC4626:\r\n        // If (1) it’s calculating the amount of shares a user has to supply to\r\n        // receive a given amount of the underlying tokens, it should round up.\r\n        shares_ = assets_.fixedPointMul(price_) + 1;\r\n    }\r\n\r\n    /// Calculate how many assets_ to withdraw for burning shares_.\r\n    /// @param shares_ Amount of shares being burned for redemption.\r\n    /// @param price_ Oracle price being redeemed against.\r\n    /// @return assets_ Amount of assets that will be redeemed for the given\r\n    /// shares.\r\n    function _calculateRedeem(uint256 shares_, uint256 price_)\r\n        internal\r\n        pure\r\n        returns (uint256 assets_)\r\n    {\r\n        // IERC4626:\r\n        // If (2) it’s determining the amount of the underlying tokens to\r\n        // transfer to them for returning a certain amount of shares, it should\r\n        // round down.\r\n        assets_ = shares_.fixedPointDiv(price_);\r\n    }\r\n\r\n    /// There is no onchain asset. The asset is offchain.\r\n    /// @inheritdoc IERC4626\r\n    function asset() public view virtual returns (address assetTokenAddress_) {\r\n        assetTokenAddress_ = _asset;\r\n    }\r\n\r\n    /// Any address can set their own minimum price.\r\n    /// This is optional as the non-standard 4626 equivalent functions accept\r\n    /// a minimum price parameter. This facilitates the 4626 interface by adding\r\n    /// one additional initial transaction for the user.\r\n    /// @param minShareRatio_ The new minimum share ratio for the `msg.sender`\r\n    /// to be used in subsequent deposit calls.\r\n    function setMinShareRatio(uint256 minShareRatio_) external {\r\n        minShareRatios[msg.sender] = minShareRatio_;\r\n    }\r\n\r\n    /// Any address can set their own price for withdrawals.\r\n    /// This is optional as the non-standard 4626 equivalent functions accept\r\n    /// a withdrawal price parameter. This facilitates the 4626 interface by\r\n    /// adding one initial transaction for the user.\r\n    /// @param id_ The new withdrawal id_ for the `msg.sender` to be used\r\n    /// in subsequent withdrawal calls. If the price does NOT match the ID of\r\n    /// a receipt held by sender then these subsequent withdrawals will fail.\r\n    /// It is the responsibility of the caller to set a valid price.\r\n    function setWithdrawId(uint256 id_) external {\r\n        withdrawIds[msg.sender] = id_;\r\n    }\r\n\r\n    /// @inheritdoc IERC4626\r\n    function totalAssets() external view virtual returns (uint256 assets_) {\r\n        // There are NO fees so the managed assets are the asset balance of the\r\n        // vault.\r\n        try IERC20(asset()).balanceOf(address(this)) returns (\r\n            uint256 balance_\r\n        ) {\r\n            assets_ = balance_;\r\n        } catch {\r\n            // It's not clear what the balance should be if querying it is\r\n            // throwing an error. The conservative error in most cases should\r\n            // be 0.\r\n            assets_ = 0;\r\n        }\r\n    }\r\n\r\n    /// Define the share ratio that assets are converted to shares on deposit.\r\n    /// This variant of `_shareRatio` MUST return the same result for all users.\r\n    /// As per IERC4626 `convertToShares` it should reflect the \"average-user's\"\r\n    /// price when all conditions are met.\r\n    /// MUST NOT revert, instead return `0` and calling functions MUST revert or\r\n    /// return values as appropriate.\r\n    function _shareRatio() internal view virtual returns (uint256 shareRatio_) {\r\n        // Default is 1:1 shares to assets.\r\n        shareRatio_ = 1e18;\r\n    }\r\n\r\n    /// Define the share ratio that deposits convert to shares.\r\n    /// This variant of `_shareRatio` MAY return different results dependant on\r\n    /// the depositor and/or recipient as per `previewDeposit` and `deposit`.\r\n    /// MUST NOT revert.\r\n    function _shareRatio(address, address)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (uint256 shareRatio_)\r\n    {\r\n        // Default is to fallback to user agnostic share ratio.\r\n        shareRatio_ = _shareRatio();\r\n    }\r\n\r\n    function _shareRatioForId(uint256)\r\n        internal\r\n        view\r\n        virtual\r\n        returns (uint256 shareRatio_)\r\n    {\r\n        // Default is the same as share ratio with no id.\r\n        shareRatio_ = _shareRatio();\r\n    }\r\n\r\n    // solhint-disable-next-line no-empty-blocks\r\n    function _nextId() internal virtual returns (uint256) {}\r\n\r\n    /// @inheritdoc IERC4626\r\n    function convertToShares(uint256 assets_)\r\n        external\r\n        view\r\n        returns (uint256 shares_)\r\n    {\r\n        shares_ = _calculateDeposit(assets_, _shareRatio(), 0);\r\n    }\r\n\r\n    /// This function is a bit weird because in reality everyone converts their\r\n    /// shares to assets at the price they minted at, NOT the current price. But\r\n    /// the spec demands that this function ignores per-user concerns.\r\n    /// @inheritdoc IERC4626\r\n    function convertToAssets(uint256 shares_)\r\n        external\r\n        view\r\n        returns (uint256 assets_)\r\n    {\r\n        assets_ = _calculateRedeem(shares_, _shareRatio());\r\n    }\r\n\r\n    /// @inheritdoc IERC4626\r\n    function maxDeposit(address)\r\n        external\r\n        pure\r\n        virtual\r\n        returns (uint256 maxAssets_)\r\n    {\r\n        // The spec states to return this if there is no deposit limit.\r\n        // Technically a deposit this large would almost certainly overflow\r\n        // somewhere in the process, but it isn't a limit imposed by the vault\r\n        // per-se, it's more that the ERC20 tokens themselves won't handle such\r\n        // large entries on their internal balances. Given typical token\r\n        // total supplies are smaller than this number, this would be a\r\n        // theoretical point only.\r\n        maxAssets_ = type(uint256).max;\r\n    }\r\n\r\n    /// @inheritdoc IERC4626\r\n    function maxMint(address)\r\n        external\r\n        pure\r\n        virtual\r\n        returns (uint256 maxShares_)\r\n    {\r\n        maxShares_ = type(uint256).max;\r\n    }\r\n\r\n    /// @inheritdoc IERC4626\r\n    function previewDeposit(uint256 assets_)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 shares_)\r\n    {\r\n        shares_ = _calculateDeposit(\r\n            assets_,\r\n            // Spec doesn't provide us with a receipient but wants a per-user\r\n            // preview so we assume that depositor = receipient.\r\n            _shareRatio(msg.sender, msg.sender),\r\n            // IERC4626:\r\n            // > MUST NOT revert due to vault specific user/global limits.\r\n            // > MAY revert due to other conditions that would also cause\r\n            // > deposit to revert.\r\n            // Unclear if the min price set by the user for themselves is a\r\n            // \"vault specific user limit\" or \"other conditions that would\r\n            // also cause deposit to revert\".\r\n            // The conservative interpretation is that the user will WANT\r\n            // the preview calculation to revert according to their own\r\n            // preferences they set for themselves onchain.\r\n            // If the user did not set a min price then the min price will be 0\r\n            // and never revert.\r\n            minShareRatios[msg.sender]\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc IERC4626\r\n    function previewMint(uint256 shares_)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 assets_)\r\n    {\r\n        assets_ = _calculateMint(\r\n            shares_,\r\n            // Spec doesn't provide us with a recipient but wants a per-user\r\n            // preview so we assume that depositor = recipient.\r\n            _shareRatio(msg.sender, msg.sender),\r\n            // IERC4626:\r\n            // > MUST NOT revert due to vault specific user/global limits.\r\n            // > MAY revert due to other conditions that would also cause mint\r\n            // > to revert.\r\n            // Unclear if the min price set by the user for themselves is a\r\n            // \"vault specific user limit\" or \"other conditions that would\r\n            // also cause mint to revert\".\r\n            // The conservative interpretation is that the user will WANT\r\n            // the preview calculation to revert according to their own\r\n            // preferences they set for themselves onchain.\r\n            // If the user did not set a min price the min price will be 0 and\r\n            // never revert.\r\n            minShareRatios[msg.sender]\r\n        );\r\n    }\r\n\r\n    /// If the sender wants to use the ERC4626 `deposit` function and set a\r\n    /// minimum price they need to call `setMinPrice` first in a separate call.\r\n    /// Alternatively they can use the off-spec overloaded `deposit` method.\r\n    /// @inheritdoc IERC4626\r\n    function deposit(uint256 assets_, address receiver_)\r\n        external\r\n        returns (uint256 shares_)\r\n    {\r\n        shares_ = deposit(assets_, receiver_, minShareRatios[msg.sender], \"\");\r\n    }\r\n\r\n    /// Overloaded `deposit` to allow `minShareRatio_` to be passed directly\r\n    /// without the additional `setMinShareRatio` call, which saves gas and can\r\n    /// provide a better UX overall.\r\n    /// @param assets_ As per IERC4626 `deposit`.\r\n    /// @param receiver_ As per IERC4626 `deposit`.\r\n    /// @param minShareRatio_ Caller can set the minimum share ratio they'll\r\n    /// accept from the oracle, otherwise the transaction is rolled back.\r\n    /// @param receiptInformation_ Forwarded to `receiptInformation` to\r\n    /// optionally emit offchain context about this deposit.\r\n    /// @return shares_ As per IERC4626 `deposit`.\r\n    function deposit(\r\n        uint256 assets_,\r\n        address receiver_,\r\n        uint256 minShareRatio_,\r\n        bytes memory receiptInformation_\r\n    ) public returns (uint256 shares_) {\r\n        uint256 shareRatio_ = _shareRatio(msg.sender, receiver_);\r\n        require(minShareRatio_ <= shareRatio_, \"MIN_SHARE_RATIO\");\r\n        shares_ = _calculateDeposit(assets_, shareRatio_, minShareRatio_);\r\n\r\n        _deposit(assets_, receiver_, shares_, _nextId(), receiptInformation_);\r\n    }\r\n\r\n    /// Handles minting and emitting events according to spec.\r\n    /// It does NOT do any calculations so shares and assets need to be handled\r\n    /// correctly according to spec including rounding, in the calling context.\r\n    /// Depositing reentrantly is never ok so we restrict that here in the\r\n    /// internal function rather than on the external methods.\r\n    /// @param assets_ As per IERC4626 `deposit`.\r\n    /// @param receiver_ As per IERC4626 `deposit`.\r\n    /// @param shares_ Amount of shares to mint for receiver. MAY be different\r\n    /// due to rounding in different contexts so caller MUST calculate\r\n    /// according to the rounding specification.\r\n    /// @param id_ ID of the 1155 receipt and MUST be provided on withdrawal.\r\n    function _deposit(\r\n        uint256 assets_,\r\n        address receiver_,\r\n        uint256 shares_,\r\n        uint256 id_,\r\n        bytes memory receiptInformation_\r\n    ) internal nonReentrant {\r\n        require(assets_ > 0, \"0_ASSETS\");\r\n        require(receiver_ != address(0), \"0_RECEIVER\");\r\n        require(shares_ > 0, \"0_SHARES\");\r\n        require(id_ > 0, \"0_ID\");\r\n        emit IERC4626.Deposit(msg.sender, receiver_, assets_, shares_);\r\n\r\n        _beforeDeposit(assets_, receiver_, shares_, id_);\r\n\r\n        // erc20 mint.\r\n        _mint(receiver_, shares_);\r\n\r\n        // erc1155 mint.\r\n        // Receiving contracts MUST implement `IERC1155Receiver`.\r\n        _mint(receiver_, id_, shares_, receiptInformation_);\r\n\r\n        receiptInformation(id_, receiptInformation_);\r\n    }\r\n\r\n    function _beforeDeposit(\r\n        uint256 assets_,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) internal virtual {\r\n        // Default behaviour is to assets before minting shares.\r\n        IERC20(asset()).safeTransferFrom(msg.sender, address(this), assets_);\r\n    }\r\n\r\n    function receiptInformation(uint256 id_, bytes memory data_) public {\r\n        // No data is noop.\r\n        if (data_.length > 0) {\r\n            _beforeReceiptInformation(id_, data_);\r\n            emit ReceiptInformation(msg.sender, id_, data_);\r\n        }\r\n    }\r\n\r\n    /// Default is no restrictions on who can add information for a receipt.\r\n    function _beforeReceiptInformation(uint256 id_, bytes memory data_)\r\n        internal\r\n        virtual\r\n    // solhint-disable-next-line no-empty-blocks\r\n    {\r\n\r\n    }\r\n\r\n    /// If the sender wants to use the ERC4626 `mint` function and set a\r\n    /// minimum price they need to call `setMinPrice` first in a separate call.\r\n    /// Alternatively they can use the off-spec overloaded `mint` method.\r\n    /// @inheritdoc IERC4626\r\n    function mint(uint256 shares_, address receiver_)\r\n        external\r\n        returns (uint256 assets_)\r\n    {\r\n        assets_ = mint(shares_, receiver_, minShareRatios[msg.sender], \"\");\r\n    }\r\n\r\n    /// Overloaded version of IERC4626 `mint` that allows directly passing the\r\n    /// minimum price to avoid additional gas and transactions.\r\n    /// @param shares_ As per IERC4626 `mint`.\r\n    /// @param receiver_ As per IERC4626 `mint`.\r\n    /// @param minShareRatio_ Caller can set the minimum price they'll accept\r\n    /// from the oracle, otherwise the transaction is rolled back.\r\n    /// @param receiptInformation_ Forwarded to `receiptInformation` to\r\n    /// optionally emit offchain context about this deposit.\r\n    /// @return assets_ As per IERC4626 `mint`.\r\n    function mint(\r\n        uint256 shares_,\r\n        address receiver_,\r\n        uint256 minShareRatio_,\r\n        bytes memory receiptInformation_\r\n    ) public returns (uint256 assets_) {\r\n        uint256 shareRatio_ = _shareRatio(msg.sender, receiver_);\r\n        require(minShareRatio_ <= shareRatio_, \"MIN_SHARE_RATIO\");\r\n        assets_ = _calculateMint(shares_, shareRatio_, minShareRatio_);\r\n        _deposit(assets_, receiver_, shares_, _nextId(), receiptInformation_);\r\n    }\r\n\r\n    /// As withdrawal requires a price the vault deposits are non fungible. This\r\n    /// means the maximum amount of underlying asset that a user can withdraw is\r\n    /// specific to the 1155 receipt they want to burn to handle the withdraw.\r\n    /// A user with multiple receipts will only ever see the maxWithdraw for a\r\n    /// single receipt. For most use cases it would be recommended to call the\r\n    /// overloaded `maxWithdraw` that has the withdraw price paramaterised. This\r\n    /// can be looped over to build a view over several withdraw prices.\r\n    /// @inheritdoc IERC4626\r\n    function maxWithdraw(address owner_)\r\n        external\r\n        view\r\n        virtual\r\n        returns (uint256 maxAssets_)\r\n    {\r\n        maxAssets_ = maxWithdraw(owner_, withdrawIds[owner_]);\r\n    }\r\n\r\n    /// Overloaded `maxWithdraw` that allows passing a receipt id directly. The\r\n    /// id needs to be provided so that we know which ERC1155 balance to\r\n    /// check the withdraw against. The burnable ERC20 is capped per-withdraw\r\n    /// to the balance of a price-bound ERC1155. If a user has multiple 1155\r\n    /// receipts they will need to call `maxWithdraw` multiple times to\r\n    /// calculate a global withdrawal limit across all receipts.\r\n    /// @param owner_ As per IERC4626 `maxWithdraw`.\r\n    /// @param id_ The reference id to check the max withdrawal against\r\n    /// for a specific receipt the owner presumably holds. Max withdrawal will\r\n    /// be 0 if the user does not hold a receipt.\r\n    /// @return maxAssets_ As per IERC4626 `maxWithdraw`.\r\n    function maxWithdraw(address owner_, uint256 id_)\r\n        public\r\n        view\r\n        returns (uint256 maxAssets_)\r\n    {\r\n        // Using `_calculateRedeem` instead of `_calculateWithdraw` becuase the\r\n        // latter requires knowing the assets being withdrawn, which is what we\r\n        // are attempting to reverse engineer from the owner's receipt balance.\r\n        maxAssets_ = _calculateRedeem(\r\n            balanceOf(owner_, id_),\r\n            _shareRatioForId(id_)\r\n        );\r\n    }\r\n\r\n    /// Previewing withdrawal will only calculate the shares required to\r\n    /// withdraw assets against their singular preset withdraw price. To\r\n    /// calculate many withdrawals for a set of recieipts it is cheaper and\r\n    /// easier to use the overloaded version that allows prices to be passed in\r\n    /// as arguments.\r\n    /// @inheritdoc IERC4626\r\n    function previewWithdraw(uint256 assets_)\r\n        external\r\n        view\r\n        returns (uint256 shares_)\r\n    {\r\n        shares_ = previewWithdraw(assets_, withdrawIds[msg.sender]);\r\n    }\r\n\r\n    /// Overloaded version of IERC4626 that allows caller to pass in the price\r\n    /// to preview. Multiple receipt holders will need to call this function\r\n    /// for each recieipt price to preview all their withdrawals.\r\n    /// @param assets_ As per IERC4626 `previewWithdraw`.\r\n    /// @param id_ The receipt to preview a withdrawal against.\r\n    /// @return shares_ As per IERC4626 `previewWithdraw`.\r\n    function previewWithdraw(uint256 assets_, uint256 id_)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 shares_)\r\n    {\r\n        shares_ = _calculateWithdraw(assets_, _shareRatioForId(id_));\r\n    }\r\n\r\n    /// Withdraws against the current withdraw price set by the owner.\r\n    /// This enables spec compliant withdrawals but is additional gas and\r\n    /// transactions for the user to set the withdraw price in storage before\r\n    /// each withdrawal. The overloaded `withdraw` function allows passing in a\r\n    /// receipt price directly, which may be cheaper and more convenient.\r\n    /// @inheritdoc IERC4626\r\n    function withdraw(\r\n        uint256 assets_,\r\n        address receiver_,\r\n        address owner_\r\n    ) external returns (uint256 shares_) {\r\n        shares_ = withdraw(assets_, receiver_, owner_, withdrawIds[owner_]);\r\n    }\r\n\r\n    /// Overloaded version of IERC4626 `withdraw` that allows the price to be\r\n    /// passed directly.\r\n    /// @param assets_ As per IERC4626 `withdraw`.\r\n    /// @param receiver_ As per IERC4626 `withdraw`.\r\n    /// @param owner_ As per IERC4626 `withdraw`.\r\n    /// @param price_ As per `_withdraw`.\r\n    /// @param price_ The mint/receipt price to withdraw against. The owner\r\n    /// MUST hold the receipt for the price in addition to the shares being\r\n    /// burned for withdrawal.\r\n    function withdraw(\r\n        uint256 assets_,\r\n        address receiver_,\r\n        address owner_,\r\n        uint256 price_\r\n    ) public returns (uint256 shares_) {\r\n        shares_ = _calculateWithdraw(assets_, price_);\r\n        _withdraw(assets_, receiver_, owner_, shares_, price_);\r\n    }\r\n\r\n    /// Handles burning shares, withdrawing assets and emitting events to spec.\r\n    /// It does NOT do any calculations so shares and assets need to be correct\r\n    /// according to spec including rounding, in the calling context.\r\n    /// Withdrawing reentrantly is never ok so we restrict that here in the\r\n    /// internal function rather than on the external methods.\r\n    /// @param assets_ As per IERC4626 `withdraw`.\r\n    /// @param receiver_ As per IERC4626 `withdraw`.\r\n    /// @param owner_ As per IERC4626 `withdraw`.\r\n    /// @param shares_ Caller MUST calculate the correct shares to burn for\r\n    /// withdrawal at `price_`. It is caller's responsibility to handle rounding\r\n    /// correctly as per 4626 spec.\r\n    /// @param id_ The receipt id to withdraw against. The owner MUST hold the\r\n    /// receipt for the price in addition to the shares being burned for\r\n    /// withdrawal.\r\n    function _withdraw(\r\n        uint256 assets_,\r\n        address receiver_,\r\n        address owner_,\r\n        uint256 shares_,\r\n        uint256 id_\r\n    ) internal nonReentrant {\r\n        require(assets_ > 0, \"0_ASSETS\");\r\n        require(receiver_ != address(0), \"0_RECEIVER\");\r\n        require(owner_ != address(0), \"0_OWNER\");\r\n        require(shares_ > 0, \"0_SHARES\");\r\n\r\n        emit IERC4626.Withdraw(msg.sender, receiver_, owner_, assets_, shares_);\r\n\r\n        // IERC4626:\r\n        // > MUST support a withdraw flow where the shares are burned from owner\r\n        // > directly where owner is msg.sender or msg.sender has ERC-20\r\n        // > approval over the shares of owner.\r\n        // Note that we do NOT require the caller has allowance over the receipt\r\n        // in order to burn the shares to withdraw assets.\r\n        if (owner_ != msg.sender) {\r\n            _spendAllowance(owner_, msg.sender, shares_);\r\n        }\r\n\r\n        // erc20 burn.\r\n        _burn(owner_, shares_);\r\n\r\n        // erc1155 burn.\r\n        _burn(owner_, id_, shares_);\r\n\r\n        _afterWithdraw(assets_, receiver_, owner_, shares_, id_);\r\n    }\r\n\r\n    function _afterWithdraw(\r\n        uint256 assets_,\r\n        address receiver_,\r\n        address,\r\n        uint256,\r\n        uint256\r\n    ) internal virtual {\r\n        // Default is to send assets after burning shares.\r\n        IERC20(asset()).safeTransfer(receiver_, assets_);\r\n    }\r\n\r\n    /// Max redemption is only relevant to the currently set withdraw price for\r\n    /// the owner. Checking a different max redemption requires the owner\r\n    /// setting a different withdraw price which costs gas and an additional\r\n    /// transaction. The overloaded maxRedeem function allows the price being\r\n    /// checked against to be passed in directly.\r\n    /// @inheritdoc IERC4626\r\n    function maxRedeem(address owner_)\r\n        external\r\n        view\r\n        returns (uint256 maxShares_)\r\n    {\r\n        maxShares_ = maxRedeem(owner_, withdrawIds[owner_]);\r\n    }\r\n\r\n    /// Overloaded maxRedeem function that allows the redemption price to be\r\n    /// passed directly. The maximum number of shares that can be redeemed is\r\n    /// simply the balance of the associated receipt NFT the user holds for the\r\n    /// given price.\r\n    /// @param owner_ As per IERC4626 `maxRedeem`.\r\n    /// @param price_ The reference price to check the owner's 1155 balance for.\r\n    /// @return maxShares_ As per IERC4626 `maxRedeem`.\r\n    function maxRedeem(address owner_, uint256 price_)\r\n        public\r\n        view\r\n        returns (uint256 maxShares_)\r\n    {\r\n        maxShares_ = balanceOf(owner_, price_);\r\n    }\r\n\r\n    /// Preview redeem is only relevant to the currently set withdraw price for\r\n    /// the caller. The overloaded previewRedeem allows the price to be passed\r\n    /// directly which may avoid gas costs and additional transactions.\r\n    /// @inheritdoc IERC4626\r\n    function previewRedeem(uint256 shares_)\r\n        external\r\n        view\r\n        returns (uint256 assets_)\r\n    {\r\n        assets_ = _calculateRedeem(shares_, withdrawIds[msg.sender]);\r\n    }\r\n\r\n    /// Overloaded previewRedeem that allows price to redeem for to be passed\r\n    /// directly.\r\n    /// @param shares_ As per IERC4626.\r\n    /// @param id_ The receipt id_ to calculate redemption against.\r\n    function previewRedeem(uint256 shares_, uint256 id_)\r\n        public\r\n        view\r\n        virtual\r\n        returns (uint256 assets_)\r\n    {\r\n        assets_ = _calculateRedeem(shares_, id_);\r\n    }\r\n\r\n    /// Redeems at the currently set withdraw price for the owner. The\r\n    /// overloaded redeem function allows the price to be passed in rather than\r\n    /// set separately in storage.\r\n    /// @inheritdoc IERC4626\r\n    function redeem(\r\n        uint256 shares_,\r\n        address receiver_,\r\n        address owner_\r\n    ) external returns (uint256 assets_) {\r\n        assets_ = redeem(shares_, receiver_, owner_, withdrawIds[owner_]);\r\n    }\r\n\r\n    /// Overloaded redeem that allows the price to redeem at to be passed in.\r\n    /// @param shares_ As per IERC4626 `redeem`.\r\n    /// @param receiver_ As per IERC4626 `redeem`.\r\n    /// @param owner_ As per IERC4626 `redeem`.\r\n    /// @param price_ The reference price to redeem against. The owner MUST hold\r\n    /// a receipt of at least `shares_` amount and `price_` ID in order to\r\n    /// redeem.\r\n    function redeem(\r\n        uint256 shares_,\r\n        address receiver_,\r\n        address owner_,\r\n        uint256 price_\r\n    ) public returns (uint256 assets_) {\r\n        assets_ = _calculateRedeem(shares_, price_);\r\n        _withdraw(assets_, receiver_, owner_, shares_, price_);\r\n    }\r\n}\r\n"
    },
    "./contracts/vault/offchainAsset/OffchainAssetVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.10;\r\n\r\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\r\nimport {OffchainAssetVault, ConstructionConfig} from \"./OffchainAssetVault.sol\";\r\n\r\n/// @title OffchainAssetVaultFactory\r\n/// @notice Factory for creating and deploying `OffchainAssetVault`.\r\ncontract OffchainAssetVaultFactory is Factory {\r\n    /// @inheritdoc Factory\r\n    function _createChild(bytes calldata data_)\r\n        internal\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        // Deploying each contract directly rather than cloning it as there\r\n        // doesn't seem to be a way to cleanly inherit both ERC20Upgradeable\r\n        // and ERC1155Upgradeable at the same time.\r\n        return\r\n            address(\r\n                new OffchainAssetVault(abi.decode(data_, (ConstructionConfig)))\r\n            );\r\n    }\r\n\r\n    /// Typed wrapper for `createChild` with Source.\r\n    /// Use original `Factory` `createChild` function signature if function\r\n    /// parameters are already encoded.\r\n    ///\r\n    /// @param config_ Construction config for the vault.\r\n    /// @return New `OffchainAssetVault` child contract address.\r\n    function createChildTyped(ConstructionConfig calldata config_)\r\n        external\r\n        returns (OffchainAssetVault)\r\n    {\r\n        return OffchainAssetVault(this.createChild(abi.encode(config_)));\r\n    }\r\n}\r\n"
    },
    "./contracts/vault/priceOracle/ERC20PriceOracleVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity =0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport {ConstructionConfig as ReceiptVaultConstructionConfig, ReceiptVault} from \"../ReceiptVault.sol\";\r\nimport \"../../oracle/price/IPriceOracle.sol\";\r\n\r\n/// All config required to construct `ERC20PriceOracleVault`.\r\n/// @param asset `ERC4626` underlying asset.\r\n/// @param name `ERC20` name for `ERC4626` shares.\r\n/// @param symbol `ERC20` symbol for `ERC4626` shares.\r\n/// @param uri `ERC1155` uri for deposit receipts.\r\n/// @param address `IPriceOracle` oracle to define share mints upon deposit.\r\nstruct ConstructionConfig {\r\n    address priceOracle;\r\n    ReceiptVaultConstructionConfig receiptVaultConfig;\r\n}\r\n\r\n/// @title ERC20PriceOracleVault\r\n/// @notice An ERC4626 vault that mints shares according to a price oracle. As\r\n/// shares are minted an associated ERC1155 NFT receipt is minted for the\r\n/// asset depositor. The price oracle defines the amount of shares minted for\r\n/// each deposit. The price oracle's base MUST be the deposited asset but the\r\n/// price quote can be anything with a reliable oracle.\r\n///\r\n/// When the assets are withdrawn from the vault, the withdrawer must provide a\r\n/// receipt from a previous deposit. The receipt amount and the original\r\n/// shares minted are the same according to the price at the time of deposit.\r\n/// The withdraw burns shares in return for assets as per ERC4626 AND burns the\r\n/// receipt nominated by the withdrawer. The current price from the oracle is\r\n/// irrelevant to withdraws, only the receipt price is relevant.\r\n///\r\n/// As an analogy, consider buying a shirt on sale and then attempting to get a\r\n/// refund for it after the sale ends. The store will refund the shirt but only\r\n/// at the sale price marked on the receipt, NOT the current price of the same\r\n/// shirt in-store.\r\n///\r\n/// This dual 20/1155 token system allows for a dynamic shares:asset mint\r\n/// ratio on deposits without withdrawals ever being able to remove more assets\r\n/// than were ever deposited.\r\n///\r\n/// Where this gets interesting is trying to discover a price for the ERC20\r\n/// share token. The share token can't be worth 0 because it represents a claim\r\n/// on a fully collateralized vault of assets. The share token also can't be\r\n/// worth more than the current oracle price as it would allow depositors to\r\n/// buy infinite assets. To see why this is true, consider that selling 1 asset\r\n/// for a token pegged to the price buys the same number of pegged tokens as\r\n/// depositing 1 asset yields minted shares. If 1 share buys more than 1 pegged\r\n/// token then depositing 1 asset and selling the minted shares buys more than\r\n/// 1 asset. This sets up an infinite loop which can't exist in a real market.\r\n///\r\n/// ERC20PriceOracleVault shares are useful primitives that convert a valuable\r\n/// but volatile asset (e.g. wBTC/wETH) into shares that trade in a range (0, 1)\r\n/// of some reference price. Such a primitive MAY have trustless utility in\r\n/// domains such as providing liquidity on DEX/AMMs, non-liquidating leverage\r\n/// for speculation, risk management, etc.\r\n///\r\n/// Note on use of price oracles:\r\n/// At the time of writing Chainlink oracles seem to be \"best in class\" oracles\r\n/// yet suffer from several points of centralisation and counterparty risk. As\r\n/// there are no owner/admin keys on `ERC20PriceOracleVault` this represents an\r\n/// existential risk to the system if the price feeds stop behaving correctly.\r\n/// This is because the wrong number of shares will be minted upon deposit and\r\n/// nobody can modify the oracle address read by the vault. Long term holders\r\n/// of the share tokens are the most likely bagholders in the case of some\r\n/// oracle degradation as the fundamental tokenomics could break in arbitrary\r\n/// ways due to incorrect minting.\r\n///\r\n/// Oracles can be silently paused:\r\n/// Such as during the UST depegging event when Luna price was misreported by\r\n/// chainlink oracles. Chainlink oracles report timestamps since last update\r\n/// but every oracle has its own \"heartbeat\" during which prices are able to\r\n/// NOT update unless the price deviation target is hit. It is impossible to\r\n/// know from onchain timestamps within a heartbeat whether a price deviation\r\n/// has not been hit or if a price deviation has been hit but the feed is\r\n/// paused. The impact of this is specific to the configuration of the feed\r\n/// which is NOT visible onchain, for example at the time of writing ETH/USD\r\n/// feed updates every block, which the XAU/USD feed has a 24 hour heartbeat.\r\n/// Even if we read the current values that may be defined in the code of the\r\n/// oracle contract (but are not exposed via the interface to be read from other\r\n/// contracts) and set the same values in our contract, the upstream values can\r\n/// be changed at any time through a contract upgrade. As Chainlink admins are\r\n/// a company acting on instruction from clients (how the example UST price\r\n/// pausing came into being) it's relatively easy for someone to request a\r\n/// pause threshold to be added, changed or removed at any time.\r\n///\r\n/// Oracles are owned and can be modified:\r\n/// The underlying aggregator for an oracle can be changed by the owner. A new\r\n/// aggregator may have different heartbeat and deviance parameters, so an\r\n/// already deployed guard against stale data could become overly conservative\r\n/// and start blocking deposits unnecessarily, for example.\r\n///\r\n/// Mitigations:\r\n/// The `IPriceOracle` contracts do their best to guard against stale or\r\n/// invalid data by erroring which would pause all new depositing, while still\r\n/// allowing withdrawing. The `ChainlinkFeedPriceOracle` also does its best to\r\n/// read the onchain data that does exist such as `decimals` before converting\r\n/// prices to 18 decimal fixed point values. The best case scenario under a\r\n/// broken oracle is that most users become aware of what is happening and pull\r\n/// their collateral. One problem is that the system is designed to force some\r\n/// collateral to be \"sticky\" in the vault as different wallets hold the 1155\r\n/// and 20 tokens, so co-ordinating them for redemption may be impossible. In\r\n/// this case it MAY be possible to build anew vault contract that includes a\r\n/// matchmaking service for the compromised vault, to redeem old collateral for\r\n/// itself and reissue new tokens against itself. At the time of writing such a\r\n/// migration path is NOT implemented.\r\n///\r\n/// Note on ERC4626 rounding requirements:\r\n/// In various places the ERC4626 specification defines whether a function\r\n/// rounds up or round down when calculating mints and burns. This is to ensure\r\n/// that rounding erros always favour the vault, in that deposited assets will\r\n/// slowly accrue as dust (1 wei per rounding error) wherever the deposit and\r\n/// withdraw round trip cannot be precisely calculated. Technically to achieve\r\n/// this we should do something like the Open Zeppelin `ceilDiv` function that\r\n/// includes checks that `X % Y == 0` before rounding up after the integer\r\n/// division that first floors the result. We don't do that. To achieve the\r\n/// stated goals of ERC4626 rounding, which is setting aside 1 wei for security\r\n/// to guarantee total withdrawals are strictly <= deposits, we always add 1\r\n/// wei to the \"round up\" function results unconditionally. This saves gas and\r\n/// simplifies the contract overall.\r\ncontract ERC20PriceOracleVault is ReceiptVault {\r\n    /// Emitted when deployed and constructed.\r\n    /// @param caller `msg.sender` that deployed the contract.\r\n    /// @param config All construction config.\r\n    event ERC20PriceOracleVaultConstruction(address caller, ConstructionConfig config);\r\n\r\n    /// The price oracle used for all minting calculations.\r\n    IPriceOracle public immutable priceOracle;\r\n\r\n    /// Constructor.\r\n    /// @param config_ All necessary config for deployment.\r\n    constructor(ConstructionConfig memory config_)\r\n        ReceiptVault(config_.receiptVaultConfig)\r\n    {\r\n        priceOracle = IPriceOracle(config_.priceOracle);\r\n        emit ERC20PriceOracleVaultConstruction(msg.sender, config_);\r\n    }\r\n\r\n    /// @inheritdoc ReceiptVault\r\n    function _nextId() view internal override returns (uint256 id_) {\r\n        id_ = priceOracle.price();\r\n    }\r\n\r\n    function _shareRatio()\r\n        internal\r\n        view\r\n        override\r\n        returns (uint256 shareRatio_)\r\n    {\r\n        // The oracle CAN error so we wrap in a try block to meet spec\r\n        // requirement that calls MUST NOT revert.\r\n        try priceOracle.price() returns (uint256 price_) {\r\n            shareRatio_ = price_;\r\n        } catch {\r\n            // Depositing assets while the price oracle is erroring will give 0\r\n            // shares (it will revert due to 0 ratio).\r\n            shareRatio_ = 0;\r\n        }\r\n    }\r\n\r\n    function _shareRatioForId(uint256 id_)\r\n        internal\r\n        pure\r\n        override\r\n        returns (uint256 shareRatio_)\r\n    {\r\n        shareRatio_ = id_;\r\n    }\r\n}\r\n"
    },
    "./contracts/vault/priceOracle/ERC20PriceOracleVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.10;\r\n\r\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\r\nimport {ERC20PriceOracleVault, ConstructionConfig} from \"./ERC20PriceOracleVault.sol\";\r\n\r\n/// @title ERC20PriceOracleVaultFactory\r\n/// @notice Factory for creating and deploying `ERC20PriceOracleVault`.\r\ncontract ERC20PriceOracleVaultFactory is Factory {\r\n    /// @inheritdoc Factory\r\n    function _createChild(bytes calldata data_)\r\n        internal\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        // This is built directly with `new` instead of cloning as we're\r\n        // optimizing for use of cheap immutables at runtime rather than cheap\r\n        // deployments.\r\n        return\r\n            address(\r\n                new ERC20PriceOracleVault(\r\n                    abi.decode(data_, (ConstructionConfig))\r\n                )\r\n            );\r\n    }\r\n\r\n    /// Typed wrapper for `createChild` with Source.\r\n    /// Use original `Factory` `createChild` function signature if function\r\n    /// parameters are already encoded.\r\n    ///\r\n    /// @param config_ construction config for the `ERC20PriceOracleVault`.\r\n    /// @return New `ERC20PriceOracleVault` child contract address.\r\n    function createChildTyped(ConstructionConfig calldata config_)\r\n        external\r\n        returns (ERC20PriceOracleVault)\r\n    {\r\n        return ERC20PriceOracleVault(this.createChild(abi.encode(config_)));\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @dev The scale of all fixed point math. This is adopting the conventions of\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\nuint256 constant FP_DECIMALS = 18;\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\n/// differences between fixed point math and regular math is multiplying or\n/// dividing by `ONE` after the appropriate scaling has been applied.\nuint256 constant FP_ONE = 1e18;\n\n/// @title FixedPointMath\n/// @notice Sometimes we want to do math with decimal values but all we have\n/// are integers, typically uint256 integers. Floats are very complex so we\n/// don't attempt to simulate them. Instead we provide a standard definition of\n/// \"one\" as 10 ** 18 and scale everything up/down to this as fixed point math.\n/// Overflows are errors as per Solidity.\nlibrary FixedPointMath {\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\n    /// @param a_ Some fixed point decimal value.\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\n    /// @return `a_` scaled to match `DECIMALS`.\n    function scale18(uint256 a_, uint256 aDecimals_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 decimals_;\n        if (FP_DECIMALS == aDecimals_) {\n            return a_;\n        } else if (FP_DECIMALS > aDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - aDecimals_;\n            }\n            return a_ * 10**decimals_;\n        } else {\n            unchecked {\n                decimals_ = aDecimals_ - FP_DECIMALS;\n            }\n            return a_ / 10**decimals_;\n        }\n    }\n\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\n    /// @param a_ A `DECIMALS` fixed point decimals.\n    /// @param targetDecimals_ The new scale of `a_`.\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\n    function scaleN(uint256 a_, uint256 targetDecimals_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 decimals_;\n        if (targetDecimals_ == FP_DECIMALS) {\n            return a_;\n        } else if (FP_DECIMALS > targetDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - targetDecimals_;\n            }\n            return a_ / 10**decimals_;\n        } else {\n            unchecked {\n                decimals_ = targetDecimals_ - FP_DECIMALS;\n            }\n            return a_ * 10**decimals_;\n        }\n    }\n\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\n    /// functions in this library are to work correctly.\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\n    /// is supported.\n    /// @param a_ Some integer of any scale.\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\n    /// @return `a_` rescaled according to `scaleBy_`.\n    function scaleBy(uint256 a_, int8 scaleBy_)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (scaleBy_ == 0) {\n            return a_;\n        } else if (scaleBy_ > 0) {\n            return a_ * 10**uint8(scaleBy_);\n        } else {\n            uint256 posScaleDownBy_;\n            unchecked {\n                posScaleDownBy_ = uint8(-scaleBy_);\n            }\n            return a_ / 10**posScaleDownBy_;\n        }\n    }\n\n    /// Fixed point multiplication in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointMul(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (a_ * b_) / FP_ONE;\n    }\n\n    /// Fixed point division in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointDiv(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (a_ * FP_ONE) / b_;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IFactory} from \"./IFactory.sol\";\n// solhint-disable-next-line max-line-length\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Factory\n/// @notice Base contract for deploying and registering child contracts.\nabstract contract Factory is IFactory, ReentrancyGuard {\n    /// @dev state to track each deployed contract address. A `Factory` will\n    /// never lie about deploying a child, unless `isChild` is overridden to do\n    /// so.\n    mapping(address => bool) private contracts;\n\n    /// Implements `IFactory`.\n    ///\n    /// `_createChild` hook must be overridden to actually create child\n    /// contract.\n    ///\n    /// Implementers may want to overload this function with a typed equivalent\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\n    /// tooling and other scripts. To minimise gas costs for deployment it is\n    /// expected that the tooling will consume the typed ABI, then encode the\n    /// arguments and pass them to this function directly.\n    ///\n    /// @param data_ ABI encoded data to pass to child contract constructor.\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        returns (address);\n\n    /// Implements `IFactory`.\n    ///\n    /// Calls the `_createChild` hook that inheriting contracts must override.\n    /// Registers child contract address such that `isChild` is `true`.\n    /// Emits `NewChild` event.\n    ///\n    /// @param data_ Encoded data to pass down to child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_)\n        external\n        virtual\n        override\n        nonReentrant\n        returns (address)\n    {\n        // Create child contract using hook.\n        address child_ = _createChild(data_);\n        // Ensure the child at this address has not previously been deployed.\n        require(!contracts[child_], \"DUPLICATE_CHILD\");\n        // Register child contract address to `contracts` mapping.\n        contracts[child_] = true;\n        // Emit `NewChild` event with child contract address.\n        emit IFactory.NewChild(msg.sender, child_);\n        return child_;\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// @param maybeChild_ Address of child contract to look up.\n    /// @return Returns `true` if address is a contract created by this\n    /// contract factory, otherwise `false`.\n    function isChild(address maybeChild_)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return contracts[maybeChild_];\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/factory/IFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    /// Whenever a new child contract is deployed, a `NewChild` event\n    /// containing the new child contract address MUST be emitted.\n    /// @param sender `msg.sender` that deployed the contract (factory).\n    /// @param child address of the newly deployed child.\n    event NewChild(address sender, address child);\n\n    /// Factories that clone a template contract MUST emit an event any time\n    /// they set the implementation being cloned. Factories that deploy new\n    /// contracts without cloning do NOT need to emit this.\n    /// @param sender `msg.sender` that deployed the implementation (factory).\n    /// @param implementation address of the implementation contract that will\n    /// be used for future clones if relevant.\n    event Implementation(address sender, address implementation);\n\n    /// Creates a new child contract.\n    ///\n    /// @param data_ Domain specific data for the child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_) external returns (address);\n\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// Addresses that were not deployed by `createChild` MUST NOT return\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\n    /// any contract implementing `IFactory`.\n    ///\n    /// @param maybeChild_ Address to check registration for.\n    /// @return `true` if address was deployed by this contract factory,\n    /// otherwise `false`.\n    function isChild(address maybeChild_) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role, _msgSender());\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/tier/ITier.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\n/// @title ITier\n/// @notice `ITier` is a simple interface that contracts can\n/// implement to provide membership lists for other contracts.\n///\n/// There are many use-cases for a time-preserving conditional membership list.\n///\n/// Some examples include:\n///\n/// - Self-serve whitelist to participate in fundraising\n/// - Lists of users who can claim airdrops and perks\n/// - Pooling resources with implied governance/reward tiers\n/// - POAP style attendance proofs allowing access to future exclusive events\n///\n/// @dev Standard interface to a tiered membership.\n///\n/// A \"membership\" can represent many things:\n/// - Exclusive access.\n/// - Participation in some event or process.\n/// - KYC completion.\n/// - Combination of sub-memberships.\n/// - Etc.\n///\n/// The high level requirements for a contract implementing `ITier`:\n/// - MUST represent held tiers as a `uint`.\n/// - MUST implement `report`.\n///   - The report is a `uint256` that SHOULD represent the block each tier has\n///     been continuously held since encoded as `uint32`.\n///   - The encoded tiers start at `1`; Tier `0` is implied if no tier has ever\n///     been held.\n///   - Tier `0` is NOT encoded in the report, it is simply the fallback value.\n///   - If a tier is lost the block data is erased for that tier and will be\n///     set if/when the tier is regained to the new block.\n///   - If a tier is held but the historical block information is not available\n///     the report MAY return `0x00000000` for all held tiers.\n///   - Tiers that are lost or have never been held MUST return `0xFFFFFFFF`.\n/// - SHOULD implement `setTier`.\n///   - Contracts SHOULD revert with `SET_TIER` error if they cannot\n///     meaningfully set a tier directly.\n///     For example a contract that can only derive a membership tier by\n///     reading the state of an external contract cannot set tiers.\n///   - Contracts implementing `setTier` SHOULD error with `SET_ZERO_TIER`\n///     if tier 0 is being set.\n/// - MUST emit `TierChange` when `setTier` successfully writes a new tier.\n///   - Contracts that cannot meaningfully set a tier are exempt.\n///\n/// So the four possible states and report values are:\n/// - Tier is held and block is known: Block is in the report\n/// - Tier is held but block is NOT known: `0` is in the report\n/// - Tier is NOT held: `0xFF..` is in the report\n/// - Tier is unknown: `0xFF..` is in the report\ninterface ITier {\n    /// Every time a tier changes we log start and end tier against the\n    /// account.\n    /// This MAY NOT be emitted if reports are being read from the state of an\n    /// external contract.\n    /// The start tier MAY be lower than the current tier as at the block this\n    /// event is emitted in.\n    /// @param sender The `msg.sender` that authorized the tier change.\n    /// @param account The account changing tier.\n    /// @param startTier The previous tier the account held.\n    /// @param endTier The newly acquired tier the account now holds.\n    /// @param data The associated data for the tier change.\n    event TierChange(\n        address sender,\n        address account,\n        uint256 startTier,\n        uint256 endTier,\n        bytes data\n    );\n\n    /// @notice Users can set their own tier by calling `setTier`.\n    ///\n    /// The contract that implements `ITier` is responsible for checking\n    /// eligibility and/or taking actions required to set the tier.\n    ///\n    /// For example, the contract must take/refund any tokens relevant to\n    /// changing the tier.\n    ///\n    /// Obviously the user is responsible for any approvals for this action\n    /// prior to calling `setTier`.\n    ///\n    /// When the tier is changed a `TierChange` event will be emmited as:\n    /// ```\n    /// event TierChange(address account, uint startTier, uint endTier);\n    /// ```\n    ///\n    /// The `setTier` function includes arbitrary data as the third\n    /// parameter. This can be used to disambiguate in the case that\n    /// there may be many possible options for a user to achieve some tier.\n    ///\n    /// For example, consider the case where tier 3 can be achieved\n    /// by EITHER locking 1x rare NFT or 3x uncommon NFTs. A user with both\n    /// could use `data` to explicitly state their intent.\n    ///\n    /// NOTE however that _any_ address can call `setTier` for any other\n    /// address.\n    ///\n    /// If you implement `data` or anything that changes state then be very\n    /// careful to avoid griefing attacks.\n    ///\n    /// The `data` parameter can also be ignored by the contract implementing\n    /// `ITier`. For example, ERC20 tokens are fungible so only the balance\n    /// approved by the user is relevant to a tier change.\n    ///\n    /// The `setTier` function SHOULD prevent users from reassigning\n    /// tier 0 to themselves.\n    ///\n    /// The tier 0 status represents never having any status.\n    /// @dev Updates the tier of an account.\n    ///\n    /// The implementing contract is responsible for all checks and state\n    /// changes required to set the tier. For example, taking/refunding\n    /// funds/NFTs etc.\n    ///\n    /// Contracts may disallow directly setting tiers, preferring to derive\n    /// reports from other onchain data.\n    /// In this case they should `revert(\"SET_TIER\");`.\n    ///\n    /// @param account Account to change the tier for.\n    /// @param endTier Tier after the change.\n    /// @param data Arbitrary input to disambiguate ownership\n    /// (e.g. NFTs to lock).\n    function setTier(\n        address account,\n        uint256 endTier,\n        bytes calldata data\n    ) external;\n\n    /// @notice A tier report is a `uint256` that contains each of the block\n    /// numbers each tier has been held continously since as a `uint32`.\n    /// There are 9 possible tier, starting with tier 0 for `0` offset or\n    /// \"never held any tier\" then working up through 8x 4 byte offsets to the\n    /// full 256 bits.\n    ///\n    /// Low bits = Lower tier.\n    ///\n    /// In hexadecimal every 8 characters = one tier, starting at tier 8\n    /// from high bits and working down to tier 1.\n    ///\n    /// `uint32` should be plenty for any blockchain that measures block times\n    /// in seconds, but reconsider if deploying to an environment with\n    /// significantly sub-second block times.\n    ///\n    /// ~135 years of 1 second blocks fit into `uint32`.\n    ///\n    /// `2^8 / (365 * 24 * 60 * 60)`\n    ///\n    /// When a user INCREASES their tier they keep all the block numbers they\n    /// already had, and get new block times for each increased tiers they have\n    /// earned.\n    ///\n    /// When a user DECREASES their tier they return to `0xFFFFFFFF` (never)\n    /// for every tier level they remove, but keep their block numbers for the\n    /// remaining tiers.\n    ///\n    /// GUIs are encouraged to make this dynamic very clear for users as\n    /// round-tripping to a lower status and back is a DESTRUCTIVE operation\n    /// for block times.\n    ///\n    /// The intent is that downstream code can provide additional benefits for\n    /// members who have maintained a certain tier for/since a long time.\n    /// These benefits can be provided by inspecting the report, and by\n    /// on-chain contracts directly,\n    /// rather than needing to work with snapshots etc.\n    /// @dev Returns the earliest block the account has held each tier for\n    /// continuously.\n    /// This is encoded as a uint256 with blocks represented as 8x\n    /// concatenated uint32.\n    /// I.e. Each 4 bytes of the uint256 represents a u32 tier start time.\n    /// The low bits represent low tiers and high bits the high tiers.\n    /// Implementing contracts should return 0xFFFFFFFF for lost and\n    /// never-held tiers.\n    ///\n    /// @param account Account to get the report for.\n    /// @return The report blocks encoded as a uint256.\n    function report(address account) external view returns (uint256);\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/tier/libraries/TierReport.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {ITier} from \"../ITier.sol\";\nimport \"./TierConstants.sol\";\n\n/// @title TierReport\n/// @notice `TierReport` implements several pure functions that can be\n/// used to interface with reports.\n/// - `tierAtBlockFromReport`: Returns the highest status achieved relative to\n/// a block number and report. Statuses gained after that block are ignored.\n/// - `tierBlock`: Returns the block that a given tier has been held\n/// since according to a report.\n/// - `truncateTiersAbove`: Resets all the tiers above the reference tier.\n/// - `updateBlocksForTierRange`: Updates a report with a block\n/// number for every tier in a range.\n/// - `updateReportWithTierAtBlock`: Updates a report to a new tier.\n/// @dev Utilities to consistently read, write and manipulate tiers in reports.\n/// The low-level bit shifting can be difficult to get right so this\n/// factors that out.\nlibrary TierReport {\n    /// Enforce upper limit on tiers so we can do unchecked math.\n    /// @param tier_ The tier to enforce bounds on.\n    modifier maxTier(uint256 tier_) {\n        require(tier_ <= TierConstants.MAX_TIER, \"MAX_TIER\");\n        _;\n    }\n\n    /// Returns the highest tier achieved relative to a block number\n    /// and report.\n    ///\n    /// Note that typically the report will be from the _current_ contract\n    /// state, i.e. `block.number` but not always. Tiers gained after the\n    /// reference block are ignored.\n    ///\n    /// When the `report` comes from a later block than the `blockNumber` this\n    /// means the user must have held the tier continuously from `blockNumber`\n    /// _through_ to the report block.\n    /// I.e. NOT a snapshot.\n    ///\n    /// @param report_ A report as per `ITier`.\n    /// @param blockNumber_ The block number to check the tiers against.\n    /// @return The highest tier held since `blockNumber` as per `report`.\n    function tierAtBlockFromReport(uint256 report_, uint256 blockNumber_)\n        internal\n        pure\n        returns (uint256)\n    {\n        unchecked {\n            for (uint256 i_ = 0; i_ < 8; i_++) {\n                if (uint32(uint256(report_ >> (i_ * 32))) > blockNumber_) {\n                    return i_;\n                }\n            }\n            return TierConstants.MAX_TIER;\n        }\n    }\n\n    /// Returns the block that a given tier has been held since from a report.\n    ///\n    /// The report MUST encode \"never\" as 0xFFFFFFFF. This ensures\n    /// compatibility with `tierAtBlockFromReport`.\n    ///\n    /// @param report_ The report to read a block number from.\n    /// @param tier_ The Tier to read the block number for.\n    /// @return The block number this has been held since.\n    function tierBlock(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256)\n    {\n        unchecked {\n            // ZERO is a special case. Everyone has always been at least ZERO,\n            // since block 0.\n            if (tier_ == 0) {\n                return 0;\n            }\n\n            uint256 offset_ = (tier_ - 1) * 32;\n            return uint256(uint32(uint256(report_ >> offset_)));\n        }\n    }\n\n    /// Resets all the tiers above the reference tier to 0xFFFFFFFF.\n    ///\n    /// @param report_ Report to truncate with high bit 1s.\n    /// @param tier_ Tier to truncate above (exclusive).\n    /// @return Truncated report.\n    function truncateTiersAbove(uint256 report_, uint256 tier_)\n        internal\n        pure\n        maxTier(tier_)\n        returns (uint256)\n    {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            uint256 mask_ = (TierConstants.NEVER_REPORT >> offset_) << offset_;\n            return report_ | mask_;\n        }\n    }\n\n    /// Updates a report with a block number for a given tier.\n    /// More gas efficient than `updateBlocksForTierRange` if only a single\n    /// tier is being modified.\n    /// The tier at/above the given tier is updated. E.g. tier `0` will update\n    /// the block for tier `1`.\n    /// @param report_ Report to use as the baseline for the updated report.\n    /// @param tier_ The tier level to update.\n    /// @param blockNumber_ The new block number for `tier_`.\n    function updateBlockAtTier(\n        uint256 report_,\n        uint256 tier_,\n        uint256 blockNumber_\n    ) internal pure maxTier(tier_) returns (uint256) {\n        unchecked {\n            uint256 offset_ = tier_ * 32;\n            return\n                (report_ &\n                    ~uint256(uint256(TierConstants.NEVER_TIER) << offset_)) |\n                uint256(blockNumber_ << offset_);\n        }\n    }\n\n    /// Updates a report with a block number for every tier in a range.\n    ///\n    /// Does nothing if the end status is equal or less than the start tier.\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier at the start of the range (exclusive).\n    /// @param endTier_ The tier at the end of the range (inclusive).\n    /// @param blockNumber_ The block number to set for every tier in the\n    /// range.\n    /// @return The updated report.\n    function updateBlocksForTierRange(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) internal pure maxTier(endTier_) returns (uint256) {\n        unchecked {\n            uint256 offset_;\n            for (uint256 i_ = startTier_; i_ < endTier_; i_++) {\n                offset_ = i_ * 32;\n                report_ =\n                    (report_ &\n                        ~uint256(\n                            uint256(TierConstants.NEVER_TIER) << offset_\n                        )) |\n                    uint256(blockNumber_ << offset_);\n            }\n            return report_;\n        }\n    }\n\n    /// Updates a report to a new status.\n    ///\n    /// Internally dispatches to `truncateTiersAbove` and\n    /// `updateBlocksForTierRange`.\n    /// The dispatch is based on whether the new tier is above or below the\n    /// current tier.\n    /// The `startTier_` MUST match the result of `tierAtBlockFromReport`.\n    /// It is expected the caller will know the current tier when\n    /// calling this function and need to do other things in the calling scope\n    /// with it.\n    ///\n    /// @param report_ The report to update.\n    /// @param startTier_ The tier to start updating relative to. Data above\n    /// this tier WILL BE LOST so probably should be the current tier.\n    /// @param endTier_ The new highest tier held, at the given block number.\n    /// @param blockNumber_ The block number to update the highest tier to, and\n    /// intermediate tiers from `startTier_`.\n    /// @return The updated report.\n    function updateReportWithTierAtBlock(\n        uint256 report_,\n        uint256 startTier_,\n        uint256 endTier_,\n        uint256 blockNumber_\n    ) internal pure returns (uint256) {\n        return\n            endTier_ < startTier_\n                ? truncateTiersAbove(report_, endTier_)\n                : updateBlocksForTierRange(\n                    report_,\n                    startTier_,\n                    endTier_,\n                    blockNumber_\n                );\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/tier/libraries/TierConstants.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @title TierConstants\n/// @notice Constants for use with tier logic.\nlibrary TierConstants {\n    /// NEVER is 0xFF.. as it is infinitely in the future.\n    /// NEVER for an entire report.\n    uint256 internal constant NEVER_REPORT = type(uint256).max;\n    /// NEVER for a single tier.\n    uint32 internal constant NEVER_TIER = type(uint32).max;\n\n    /// Always is 0 as it is the genesis block.\n    /// Tiers can't predate the chain but they can predate an `ITier` contract.\n    uint256 internal constant ALWAYS = 0;\n\n    /// Account has never held a tier.\n    uint256 internal constant TIER_ZERO = 0;\n\n    /// Magic number for tier one.\n    uint256 internal constant TIER_ONE = 1;\n    /// Magic number for tier two.\n    uint256 internal constant TIER_TWO = 2;\n    /// Magic number for tier three.\n    uint256 internal constant TIER_THREE = 3;\n    /// Magic number for tier four.\n    uint256 internal constant TIER_FOUR = 4;\n    /// Magic number for tier five.\n    uint256 internal constant TIER_FIVE = 5;\n    /// Magic number for tier six.\n    uint256 internal constant TIER_SIX = 6;\n    /// Magic number for tier seven.\n    uint256 internal constant TIER_SEVEN = 7;\n    /// Magic number for tier eight.\n    uint256 internal constant TIER_EIGHT = 8;\n    /// Maximum tier is `TIER_EIGHT`.\n    uint256 internal constant MAX_TIER = TIER_EIGHT;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/ERC20Snapshot.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Arrays.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the begining of each new block. When overridding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20Snapshot is ERC20 {\n    // Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n    // https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n    using Arrays for uint256[];\n    using Counters for Counters.Counter;\n\n    // Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n    // Snapshot struct, but that would impede usage of functions that work on an array.\n    struct Snapshots {\n        uint256[] ids;\n        uint256[] values;\n    }\n\n    mapping(address => Snapshots) private _accountBalanceSnapshots;\n    Snapshots private _totalSupplySnapshots;\n\n    // Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n    Counters.Counter private _currentSnapshotId;\n\n    /**\n     * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n     */\n    event Snapshot(uint256 id);\n\n    /**\n     * @dev Creates a new snapshot and returns its snapshot id.\n     *\n     * Emits a {Snapshot} event that contains the same id.\n     *\n     * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n     * set of accounts, for example using {AccessControl}, or it may be open to the public.\n     *\n     * [WARNING]\n     * ====\n     * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n     * you must consider that it can potentially be used by attackers in two ways.\n     *\n     * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n     * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n     * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n     * section above.\n     *\n     * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n     * ====\n     */\n    function _snapshot() internal virtual returns (uint256) {\n        _currentSnapshotId.increment();\n\n        uint256 currentId = _getCurrentSnapshotId();\n        emit Snapshot(currentId);\n        return currentId;\n    }\n\n    /**\n     * @dev Get the current snapshotId\n     */\n    function _getCurrentSnapshotId() internal view virtual returns (uint256) {\n        return _currentSnapshotId.current();\n    }\n\n    /**\n     * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n     */\n    function balanceOfAt(address account, uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);\n\n        return snapshotted ? value : balanceOf(account);\n    }\n\n    /**\n     * @dev Retrieves the total supply at the time `snapshotId` was created.\n     */\n    function totalSupplyAt(uint256 snapshotId) public view virtual returns (uint256) {\n        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnapshots);\n\n        return snapshotted ? value : totalSupply();\n    }\n\n    // Update balance and/or total supply snapshots before the values are modified. This is implemented\n    // in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from == address(0)) {\n            // mint\n            _updateAccountSnapshot(to);\n            _updateTotalSupplySnapshot();\n        } else if (to == address(0)) {\n            // burn\n            _updateAccountSnapshot(from);\n            _updateTotalSupplySnapshot();\n        } else {\n            // transfer\n            _updateAccountSnapshot(from);\n            _updateAccountSnapshot(to);\n        }\n    }\n\n    function _valueAt(uint256 snapshotId, Snapshots storage snapshots) private view returns (bool, uint256) {\n        require(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n        require(snapshotId <= _getCurrentSnapshotId(), \"ERC20Snapshot: nonexistent id\");\n\n        // When a valid snapshot is queried, there are three possibilities:\n        //  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n        //  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n        //  to this id is the current one.\n        //  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n        //  requested id, and its value is the one to return.\n        //  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n        //  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n        //  larger than the requested one.\n        //\n        // In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n        // it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n        // exactly this.\n\n        uint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n        if (index == snapshots.ids.length) {\n            return (false, 0);\n        } else {\n            return (true, snapshots.values[index]);\n        }\n    }\n\n    function _updateAccountSnapshot(address account) private {\n        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n    }\n\n    function _updateTotalSupplySnapshot() private {\n        _updateSnapshot(_totalSupplySnapshots, totalSupply());\n    }\n\n    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {\n        uint256 currentId = _getCurrentSnapshotId();\n        if (_lastSnapshotId(snapshots.ids) < currentId) {\n            snapshots.ids.push(currentId);\n            snapshots.values.push(currentValue);\n        }\n    }\n\n    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {\n        if (ids.length == 0) {\n            return 0;\n        } else {\n            return ids[ids.length - 1];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Arrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Arrays.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n    /**\n     * @dev Searches a sorted `array` and returns the first index that contains\n     * a value greater or equal to `element`. If no such index exists (i.e. all\n     * values in the array are strictly less than `element`), the array length is\n     * returned. Time complexity O(log n).\n     *\n     * `array` is expected to be sorted in ascending order, and to contain no\n     * repeated elements.\n     */\n    function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (array[mid] > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && array[low - 1] == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a / b + (a % b == 0 ? 0 : 1);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: balance query for the zero address\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: transfer caller is not owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": ["id", "ast"]
      }
    }
  }
}
