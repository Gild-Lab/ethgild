{
  "language": "Solidity",
  "sources": {
    "./contracts/oracle/price/chainlink/ChainlinkFeedPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity =0.8.10;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport \"@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\n\r\nimport \"../IPriceOracle.sol\";\r\n\r\n/// All data required to construct the contract.\r\n/// @param feed The address of the underlying chainlink oracle.\r\n/// @param staleAfter The duration after which price data will be considered\r\n/// too stale for use and error.\r\nstruct ConstructionConfig {\r\n    address feed;\r\n    uint256 staleAfter;\r\n}\r\n\r\n/// @title ChainlinkFeedPriceOracle\r\n/// @notice Converts a single chainlink price oracle to an `IPriceOracle`.\r\n/// This involves:\r\n/// - Fetching latest round data from chainlink\r\n/// - Rejecting negative price values\r\n/// - Fetching decimals from chainlink\r\n/// - Rescaling chainlink price data to target decimals if required\r\ncontract ChainlinkFeedPriceOracle is IPriceOracle {\r\n    using SafeCast for int256;\r\n    using FixedPointMath for uint256;\r\n\r\n    /// Emitted upon deployment and construction of oracle\r\n    /// @param sender `msg.sender` that deploys the oracle.\r\n    /// @param config All config used to construct the contract.\r\n    event Construction(address sender, ConstructionConfig config);\r\n\r\n    /// Immutable copy of `ConstructionConfig.feed`.\r\n    AggregatorV3Interface public immutable feed;\r\n\r\n    /// Immutable copy of `ConstructionConfig.staleAfter`.\r\n    uint256 public immutable staleAfter;\r\n\r\n    /// Constructor.\r\n    /// @param config_ All config required to construct the contract.\r\n    constructor(ConstructionConfig memory config_) {\r\n        feed = AggregatorV3Interface(config_.feed);\r\n        staleAfter = config_.staleAfter;\r\n        emit Construction(msg.sender, config_);\r\n    }\r\n\r\n    /// @inheritdoc IPriceOracle\r\n    function price() external view override returns (uint256 price_) {\r\n        (, int256 answer_, , uint256 updatedAt_, ) = feed.latestRoundData();\r\n        require(answer_ > 0, \"MIN_BASE_PRICE\");\r\n        // Checked time comparison ensures no updates from the future as that\r\n        // would overflow, and no stale prices.\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(block.timestamp - updatedAt_ < staleAfter, \"STALE_PRICE\");\r\n\r\n        // Safely cast the answer to uint and scale it to 18 decimal FP.\r\n        price_ = answer_.toUint256().scale18(feed.decimals());\r\n    }\r\n}\r\n"
    },
    "./contracts/oracle/price/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity ^0.8.0;\r\n\r\n/// Simplified interface into a price oracle.\r\n/// The intention is that some more complex oracle interface such as chainlink\r\n/// `AggregatorV3Interface` is wrapped/adapted by a contract that implements\r\n/// `IPriceOracle` to produce a single final value.\r\n///\r\n/// Prices from an `IPriceOracle` MUST be:\r\n/// - The latest available data/value\r\n/// - Fresh enough or error if only too-stale data is available\r\n/// - Represented as positive uint values only or error\r\n/// - 18 decimal fixed point values representing a ratio (price) between \"base\"\r\n/// and \"quote\" token.\r\n///\r\n/// If for any reason the underlying oracle cannot produce an appropriate\r\n/// answer it MUST error rather than return inappropriate values. The ability\r\n/// to do so MAY be limited by upstream providers (e.g. Chainlink silently\r\n/// pausing price data during a heartbeat).\r\nabstract contract IPriceOracle {\r\n    /// Returns the current/latest price according to the oracle.\r\n    function price() external view virtual returns (uint256 price_);\r\n}\r\n"
    },
    "./contracts/oracle/price/chainlink/ChainlinkFeedPriceOracleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.10;\r\n\r\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\r\nimport \"./ChainlinkFeedPriceOracle.sol\";\r\n\r\n/// @title ChainlinkFeedPriceOracleFactory\r\n/// @notice Factory for creating and deploying `ChainlinkFeedPriceOracle`.\r\ncontract ChainlinkFeedPriceOracleFactory is Factory {\r\n    /// @inheritdoc Factory\r\n    function _createChild(bytes calldata data_)\r\n        internal\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        // This is built directly with `new` instead of cloning as we're\r\n        // optimizing for use of cheap immutables at runtime rather than cheap\r\n        // deployments.\r\n        return\r\n            address(\r\n                new ChainlinkFeedPriceOracle(\r\n                    abi.decode(data_, (ConstructionConfig))\r\n                )\r\n            );\r\n    }\r\n\r\n    /// Typed wrapper for `createChild` with Source.\r\n    /// Use original `Factory` `createChild` function signature if function\r\n    /// parameters are already encoded.\r\n    ///\r\n    /// @param config_ construction configuration for the oracle.\r\n    /// @return New `ChainlinkFeedPriceOracle` child contract address.\r\n    function createChildTyped(ConstructionConfig memory config_)\r\n        external\r\n        returns (ChainlinkFeedPriceOracle)\r\n    {\r\n        return ChainlinkFeedPriceOracle(this.createChild(abi.encode(config_)));\r\n    }\r\n}\r\n"
    },
    "./contracts/oracle/price/TwoPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity =0.8.10;\r\n\r\nimport \"./IPriceOracle.sol\";\r\nimport \"@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol\";\r\n\r\n/// All config required for construction.\r\n/// @param base The base price of the merged pair, will be the numerator.\r\n/// @param quote The quote price of the merged pair, will be the denominator.\r\nstruct ConstructionConfig {\r\n    address base;\r\n    address quote;\r\n}\r\n\r\n/// @title TwoPriceOracle\r\n/// Any time we have two price feeds that share a denominator we can calculate\r\n/// a single price by dividing them.\r\n///\r\n/// For example, an ETH/USD (base) and an XAU/USD (quote) price can be combined\r\n/// to a single ETH/XAU price as (ETH/USD) / (XAU/USD).\r\ncontract TwoPriceOracle is IPriceOracle {\r\n    using FixedPointMath for uint256;\r\n\r\n    /// Emitted upon deployment and construction.\r\n    event Construction(address sender, ConstructionConfig config);\r\n\r\n    /// As per `ConstructionConfig.base`.\r\n    IPriceOracle public immutable base;\r\n    /// As per `ConstructionConfig.quote`.\r\n    IPriceOracle public immutable quote;\r\n\r\n    /// Constructor.\r\n    /// @param config_ All configr required to construct.\r\n    constructor(ConstructionConfig memory config_) {\r\n        base = IPriceOracle(config_.base);\r\n        quote = IPriceOracle(config_.quote);\r\n        emit Construction(msg.sender, config_);\r\n    }\r\n\r\n    /// Calculates the price as `base / quote`.\r\n    /// @inheritdoc IPriceOracle\r\n    function price() external view override returns (uint256 price_) {\r\n        price_ = base.price().fixedPointDiv(quote.price());\r\n    }\r\n}\r\n"
    },
    "./contracts/oracle/price/TwoPriceOracleFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity =0.8.10;\r\n\r\nimport {Factory} from \"@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol\";\r\nimport \"./TwoPriceOracle.sol\";\r\n\r\n/// @title TwoPriceOracleFactory\r\n/// @notice Factory for creating and deploying `TwoPriceOracle`.\r\ncontract TwoPriceOracleFactory is Factory {\r\n    /// @inheritdoc Factory\r\n    function _createChild(bytes calldata data_)\r\n        internal\r\n        virtual\r\n        override\r\n        returns (address)\r\n    {\r\n        // This is built directly with `new` instead of cloning as we're\r\n        // optimizing for use of cheap immutables at runtime rather than cheap\r\n        // deployments.\r\n        return\r\n            address(\r\n                new TwoPriceOracle(abi.decode(data_, (ConstructionConfig)))\r\n            );\r\n    }\r\n\r\n    /// Typed wrapper for `createChild` with Source.\r\n    /// Use original `Factory` `createChild` function signature if function\r\n    /// parameters are already encoded.\r\n    ///\r\n    /// @param config_ Construction config for the oracle.\r\n    /// @return New `ChainlinkFeedPriceOracle` child contract address.\r\n    function createChildTyped(ConstructionConfig memory config_)\r\n        external\r\n        returns (TwoPriceOracle)\r\n    {\r\n        return TwoPriceOracle(this.createChild(abi.encode(config_)));\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/math/FixedPointMath.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\n/// @dev The scale of all fixed point math. This is adopting the conventions of\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\nuint256 constant FP_DECIMALS = 18;\n/// @dev The number `1` in the standard fixed point math scaling. Most of the\n/// differences between fixed point math and regular math is multiplying or\n/// dividing by `ONE` after the appropriate scaling has been applied.\nuint256 constant FP_ONE = 1e18;\n\n/// @title FixedPointMath\n/// @notice Sometimes we want to do math with decimal values but all we have\n/// are integers, typically uint256 integers. Floats are very complex so we\n/// don't attempt to simulate them. Instead we provide a standard definition of\n/// \"one\" as 10 ** 18 and scale everything up/down to this as fixed point math.\n/// Overflows are errors as per Solidity.\nlibrary FixedPointMath {\n    /// Scale a fixed point decimal of some scale factor to match `DECIMALS`.\n    /// @param a_ Some fixed point decimal value.\n    /// @param aDecimals_ The number of fixed decimals of `a_`.\n    /// @return `a_` scaled to match `DECIMALS`.\n    function scale18(uint256 a_, uint256 aDecimals_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 decimals_;\n        if (FP_DECIMALS == aDecimals_) {\n            return a_;\n        } else if (FP_DECIMALS > aDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - aDecimals_;\n            }\n            return a_ * 10**decimals_;\n        } else {\n            unchecked {\n                decimals_ = aDecimals_ - FP_DECIMALS;\n            }\n            return a_ / 10**decimals_;\n        }\n    }\n\n    /// Scale a fixed point decimals of `DECIMALS` to some other scale.\n    /// @param a_ A `DECIMALS` fixed point decimals.\n    /// @param targetDecimals_ The new scale of `a_`.\n    /// @return `a_` rescaled from `DECIMALS` to `targetDecimals_`.\n    function scaleN(uint256 a_, uint256 targetDecimals_)\n        internal\n        pure\n        returns (uint256)\n    {\n        uint256 decimals_;\n        if (targetDecimals_ == FP_DECIMALS) {\n            return a_;\n        } else if (FP_DECIMALS > targetDecimals_) {\n            unchecked {\n                decimals_ = FP_DECIMALS - targetDecimals_;\n            }\n            return a_ / 10**decimals_;\n        } else {\n            unchecked {\n                decimals_ = targetDecimals_ - FP_DECIMALS;\n            }\n            return a_ * 10**decimals_;\n        }\n    }\n\n    /// Scale a fixed point up or down by `scaleBy_` orders of magnitude.\n    /// The caller MUST ensure the end result matches `DECIMALS` if other\n    /// functions in this library are to work correctly.\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\n    /// is supported.\n    /// @param a_ Some integer of any scale.\n    /// @param scaleBy_ OOMs to scale `a_` up or down by.\n    /// @return `a_` rescaled according to `scaleBy_`.\n    function scaleBy(uint256 a_, int8 scaleBy_)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (scaleBy_ == 0) {\n            return a_;\n        } else if (scaleBy_ > 0) {\n            return a_ * 10**uint8(scaleBy_);\n        } else {\n            uint256 posScaleDownBy_;\n            unchecked {\n                posScaleDownBy_ = uint8(-scaleBy_);\n            }\n            return a_ / 10**posScaleDownBy_;\n        }\n    }\n\n    /// Fixed point multiplication in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` multiplied by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointMul(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (a_ * b_) / FP_ONE;\n    }\n\n    /// Fixed point division in native scale decimals.\n    /// Both `a_` and `b_` MUST be `DECIMALS` fixed point decimals.\n    /// @param a_ First term.\n    /// @param b_ Second term.\n    /// @return `a_` divided by `b_` to `DECIMALS` fixed point decimals.\n    function fixedPointDiv(uint256 a_, uint256 b_)\n        internal\n        pure\n        returns (uint256)\n    {\n        return (a_ * FP_ONE) / b_;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits.\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/factory/Factory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity =0.8.10;\n\nimport {IFactory} from \"./IFactory.sol\";\n// solhint-disable-next-line max-line-length\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/// @title Factory\n/// @notice Base contract for deploying and registering child contracts.\nabstract contract Factory is IFactory, ReentrancyGuard {\n    /// @dev state to track each deployed contract address. A `Factory` will\n    /// never lie about deploying a child, unless `isChild` is overridden to do\n    /// so.\n    mapping(address => bool) private contracts;\n\n    /// Implements `IFactory`.\n    ///\n    /// `_createChild` hook must be overridden to actually create child\n    /// contract.\n    ///\n    /// Implementers may want to overload this function with a typed equivalent\n    /// to expose domain specific structs etc. to the compiled ABI consumed by\n    /// tooling and other scripts. To minimise gas costs for deployment it is\n    /// expected that the tooling will consume the typed ABI, then encode the\n    /// arguments and pass them to this function directly.\n    ///\n    /// @param data_ ABI encoded data to pass to child contract constructor.\n    function _createChild(bytes calldata data_)\n        internal\n        virtual\n        returns (address);\n\n    /// Implements `IFactory`.\n    ///\n    /// Calls the `_createChild` hook that inheriting contracts must override.\n    /// Registers child contract address such that `isChild` is `true`.\n    /// Emits `NewChild` event.\n    ///\n    /// @param data_ Encoded data to pass down to child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_)\n        external\n        virtual\n        override\n        nonReentrant\n        returns (address)\n    {\n        // Create child contract using hook.\n        address child_ = _createChild(data_);\n        // Ensure the child at this address has not previously been deployed.\n        require(!contracts[child_], \"DUPLICATE_CHILD\");\n        // Register child contract address to `contracts` mapping.\n        contracts[child_] = true;\n        // Emit `NewChild` event with child contract address.\n        emit IFactory.NewChild(msg.sender, child_);\n        return child_;\n    }\n\n    /// Implements `IFactory`.\n    ///\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// @param maybeChild_ Address of child contract to look up.\n    /// @return Returns `true` if address is a contract created by this\n    /// contract factory, otherwise `false`.\n    function isChild(address maybeChild_)\n        external\n        view\n        virtual\n        override\n        returns (bool)\n    {\n        return contracts[maybeChild_];\n    }\n}\n"
    },
    "@beehiveinnovation/rain-protocol/contracts/factory/IFactory.sol": {
      "content": "// SPDX-License-Identifier: CAL\npragma solidity ^0.8.0;\n\ninterface IFactory {\n    /// Whenever a new child contract is deployed, a `NewChild` event\n    /// containing the new child contract address MUST be emitted.\n    /// @param sender `msg.sender` that deployed the contract (factory).\n    /// @param child address of the newly deployed child.\n    event NewChild(address sender, address child);\n\n    /// Factories that clone a template contract MUST emit an event any time\n    /// they set the implementation being cloned. Factories that deploy new\n    /// contracts without cloning do NOT need to emit this.\n    /// @param sender `msg.sender` that deployed the implementation (factory).\n    /// @param implementation address of the implementation contract that will\n    /// be used for future clones if relevant.\n    event Implementation(address sender, address implementation);\n\n    /// Creates a new child contract.\n    ///\n    /// @param data_ Domain specific data for the child contract constructor.\n    /// @return New child contract address.\n    function createChild(bytes calldata data_) external returns (address);\n\n    /// Checks if address is registered as a child contract of this factory.\n    ///\n    /// Addresses that were not deployed by `createChild` MUST NOT return\n    /// `true` from `isChild`. This is CRITICAL to the security guarantees for\n    /// any contract implementing `IFactory`.\n    ///\n    /// @param maybeChild_ Address to check registration for.\n    /// @return `true` if address was deployed by this contract factory,\n    /// otherwise `false`.\n    function isChild(address maybeChild_) external view returns (bool);\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": ["id", "ast"]
      }
    }
  }
}
